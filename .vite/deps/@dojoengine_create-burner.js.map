{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/connectors/base.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/connectors/injected.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/errors.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/connectors/discovery.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/connectors/helpers.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/connectors/mock.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/context/starknet.tsx", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/context/account.tsx", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/context/index.tsx", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/explorers/starkCompass.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/explorers/starkscan.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/explorers/viewblock.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/explorers/voyager.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/jsonrpc.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/public.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/alchemy.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/blast.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/infura.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/lava.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/nethermind.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/providers/reddio.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useAccount.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useConnect.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/query.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useBalance.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useContract.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useInvalidateOnBlock.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useBlockNumber.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useNetwork.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useBlock.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useContractFactory.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useContractRead.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useContractWrite.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useExplorer.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useDeployAccount.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useDisconnect.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useProvider.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useSign.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useStarkAddress.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useStarkName.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useWaitForTransaction.ts", "../../node_modules/.pnpm/@starknet-react+core@2.3.0_get-starknet-core@3.3.0_react@18.3.1_starknet@6.8.0/node_modules/@starknet-react/core/src/hooks/useStarkProfile.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/connectors/burner.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/connectors/icons.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/connectors/dojoBurnerSWO.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/connectors/dojoPredeployedSWO.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/context/burnerProvider.tsx", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/hooks/useBurner.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/manager/burnerManager.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/utils/storage.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/utils/keyDerivation.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/manager/prefundAccount.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/hooks/useBurnerManager.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/hooks/useBurnerWindowObject.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/hooks/usePredeployedWindowObject.ts", "../../node_modules/.pnpm/@dojoengine+create-burner@0.6.125_react@18.3.1_starknet@6.8.0_typescript@5.4.5_zod@3.23.8/node_modules/@dojoengine/create-burner/src/manager/predeployedManager.ts", "../../node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.mjs", "../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/src/ripemd160.ts", "../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/src/_u64.ts", "../../node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/src/sha512.ts", "../../node_modules/.pnpm/@scure+bip32@1.4.0/node_modules/@scure/bip32/index.ts"],
  "sourcesContent": ["import EventEmitter from \"eventemitter3\";\nimport { AccountInterface } from \"starknet\";\n\n/** Connector icons, as base64 encoded svg. */\nexport type ConnectorIcons = {\n  /** Dark-mode icon. */\n  dark?: string;\n  /** Light-mode icon. */\n  light?: string;\n};\n\n/** Connector data. */\nexport type ConnectorData = {\n  /** Connector account. */\n  account?: string;\n  /** Connector network. */\n  chainId?: bigint;\n};\n\n/** Connector events. */\nexport interface ConnectorEvents {\n  /** Emitted when account or network changes. */\n  change(data: ConnectorData): void;\n  /** Emitted when connection is established. */\n  connect(data: ConnectorData): void;\n  /** Emitted when connection is lost. */\n  disconnect(): void;\n}\n\nexport abstract class Connector extends EventEmitter<ConnectorEvents> {\n  /** Unique connector id. */\n  abstract get id(): string;\n  /** Connector name. */\n  abstract get name(): string;\n  /** Connector icons. */\n  abstract get icon(): ConnectorIcons;\n\n  /** Whether connector is available for use */\n  abstract available(): boolean;\n  /** Whether connector is already authorized */\n  abstract ready(): Promise<boolean>;\n  /** Connect wallet. */\n  abstract connect(): Promise<ConnectorData>;\n  /** Disconnect wallet. */\n  abstract disconnect(): Promise<void>;\n  /** Get current account. */\n  abstract account(): Promise<AccountInterface>;\n  /** Get current chain id. */\n  abstract chainId(): Promise<bigint>;\n}\n", "import { goerli, mainnet, sepolia } from \"@starknet-react/chains\";\nimport { StarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserNotConnectedError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\n/** Injected connector options. */\nexport interface InjectedConnectorOptions {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name?: string;\n  /** Wallet icons. */\n  icon?: ConnectorIcons;\n}\n\n// Icons used when the injected wallet is not found and no icon is provided.\n// question-mark-circle from heroicons with color changed to black/white.\nconst WALLET_NOT_FOUND_ICON_LIGHT =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nconst WALLET_NOT_FOUND_ICON_DARK =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\n\n//  Icons used when the injected wallet is not installed\n//  Icons from media kits\nconst walletIcons = {\n  argentX:\n    \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos:\n    \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\",\n};\nexport class InjectedConnector extends Connector {\n  private _wallet?: StarknetWindowObject;\n  private _options: InjectedConnectorOptions;\n\n  constructor({ options }: { options: InjectedConnectorOptions }) {\n    super();\n    this._options = options;\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n\n  get icon(): ConnectorIcons {\n    let defaultIcon = {\n      dark:\n        this._wallet?.icon ||\n        walletIcons[this.id as keyof typeof walletIcons] ||\n        WALLET_NOT_FOUND_ICON_DARK,\n      light:\n        this._wallet?.icon ||\n        walletIcons[this.id as keyof typeof walletIcons] ||\n        WALLET_NOT_FOUND_ICON_LIGHT,\n    };\n\n    return this._options.icon ?? defaultIcon;\n  }\n\n  available(): boolean {\n    this.ensureWallet();\n    return this._wallet !== undefined;\n  }\n\n  async chainId(): Promise<bigint> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    const chainIdHex = await this._wallet.provider.getChainId();\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    this.ensureWallet();\n\n    if (!this._wallet) return false;\n    return await this._wallet.isPreauthorized();\n  }\n\n  async connect(): Promise<ConnectorData> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n\n    let accounts;\n    try {\n      accounts = await this._wallet.enable({ starknetVersion: \"v5\" });\n    } catch {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    if (!this._wallet.isConnected || !accounts) {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    this._wallet.on(\n      \"accountsChanged\",\n      async (accounts: string[] | string) => {\n        await this.onAccountsChanged(accounts);\n      },\n    );\n\n    this._wallet.on(\"networkChanged\", (network?: string) => {\n      this.onNetworkChanged(network);\n    });\n\n    await this.onAccountsChanged(accounts);\n\n    const account = this._wallet.account.address;\n    const chainId = await this.chainId();\n\n    this.emit(\"connect\", { account, chainId });\n\n    return {\n      account,\n      chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this.ensureWallet();\n\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._wallet?.isConnected) {\n      throw new UserNotConnectedError();\n    }\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    this.ensureWallet();\n\n    if (!this._wallet || !this._wallet.account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._wallet.account;\n  }\n\n  private ensureWallet() {\n    const installed = getAvailableWallets(globalThis);\n    const wallet = installed.filter((w) => w.id === this._options.id)[0];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n\n  private async onAccountsChanged(accounts: string[] | string): Promise<void> {\n    let account;\n    if (typeof accounts === \"string\") {\n      account = accounts;\n    } else {\n      account = accounts[0];\n    }\n\n    if (account) {\n      const chainId = await this.chainId();\n      this.emit(\"change\", { account, chainId });\n    } else {\n      this.emit(\"disconnect\");\n    }\n  }\n\n  private onNetworkChanged(network?: string): void {\n    switch (network) {\n      // Argent\n      case \"SN_MAIN\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"SN_GOERLI\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      case \"SN_SEPOLIA\":\n        this.emit(\"change\", { chainId: sepolia.id });\n        break;\n      // Braavos\n      case \"mainnet-alpha\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"goerli-alpha\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      case \"sepolia-alpha\":\n        this.emit(\"change\", { chainId: sepolia.id });\n        break;\n      default:\n        this.emit(\"change\", {});\n        break;\n    }\n  }\n}\n\n// biome-ignore lint: window could contain anything\nfunction getAvailableWallets(obj: Record<string, any>): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet as StarknetWindowObject;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: wallet could be anything\nfunction isWalletObject(wallet: any): boolean {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n", "export class ConnectorAlreadyConnectedError extends Error {\n  override name = \"ConnectorAlreadyConnectedError\";\n  override message = \"Connector already connected\";\n}\n\nexport class ConnectorNotConnectedError extends Error {\n  override name = \"ConnectorNotConnectedError\";\n  override message = \"Connector not connected\";\n}\n\nexport class ConnectorNotFoundError extends Error {\n  override name = \"ConnectorNotFoundError\";\n  override message = \"Connector not found\";\n}\n\nexport class UserRejectedRequestError extends Error {\n  override name = \"UserRejectedRequestError\";\n  override message = \"User rejected request\";\n}\n\nexport class UserNotConnectedError extends Error {\n  override name = \"UserNotConnectedError\";\n  override message = \"User not connected\";\n}\n\nexport class UnsupportedAccountInterfaceError extends Error {\n  override name = \"UnsupportedAccountInterfaceError\";\n  override message =\n    \"Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface\";\n}\n", "import type { StarknetWindowObject } from \"get-starknet-core\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport { Connector } from \"./base\";\nimport { injected } from \"./helpers\";\n\nexport type UseInjectedConnectorsProps = {\n  /** List of recommended connectors to display. */\n  recommended?: Connector[];\n  /** Whether to include recommended connectors in the list. */\n  includeRecommended?: \"always\" | \"onlyIfNoConnectors\";\n  /** How to order connectors. */\n  order?: \"random\" | \"alphabetical\";\n};\n\nexport type UseInjectedConnectorsResult = {\n  /** Connectors list. */\n  connectors: Connector[];\n};\n\nexport function useInjectedConnectors({\n  recommended,\n  includeRecommended = \"always\",\n  order = \"alphabetical\",\n}: UseInjectedConnectorsProps): UseInjectedConnectorsResult {\n  const [injectedConnectors, setInjectedConnectors] = useState<Connector[]>([]);\n\n  const refreshConnectors = useCallback(() => {\n    const wallets = scanObjectForWallets(window);\n    const connectors = wallets.map((wallet) => injected({ id: wallet.id }));\n    setInjectedConnectors(connectors);\n  }, [setInjectedConnectors]);\n\n  useEffect(() => {\n    refreshConnectors();\n  }, [refreshConnectors]);\n\n  const connectors = useMemo(() => {\n    return mergeConnectors(injectedConnectors, recommended ?? [], {\n      includeRecommended,\n      order,\n    });\n  }, [injectedConnectors, recommended, includeRecommended, order]);\n\n  return { connectors };\n}\n\nfunction mergeConnectors(\n  injected: Connector[],\n  recommended: Connector[],\n  {\n    includeRecommended,\n    order,\n  }: Required<Pick<UseInjectedConnectorsProps, \"includeRecommended\" | \"order\">>,\n): Connector[] {\n  const injectedIds = new Set(injected.map((connector) => connector.id));\n  const allConnectors = injected;\n  const shouldAddRecommended =\n    includeRecommended === \"always\" ||\n    (includeRecommended === \"onlyIfNoConnectors\" && injected.length === 0);\n  if (shouldAddRecommended) {\n    allConnectors.push(\n      ...recommended.filter((connector) => !injectedIds.has(connector.id)),\n    );\n  }\n\n  if (order === \"random\") {\n    return shuffle(allConnectors);\n  }\n  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction shuffle<T>(arr: T[]): T[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    // @ts-ignore: not important\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\n\nexport function scanObjectForWallets(\n  // biome-ignore lint: window could contain anything\n  obj: Record<string, any>,\n): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: window could contain anything\nfunction isWalletObject(wallet: any): wallet is StarknetWindowObject {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n", "import { InjectedConnector } from \"./injected\";\n\nexport function argent(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"argentX\",\n      name: \"Argent\",\n    },\n  });\n}\n\nexport function braavos(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"braavos\",\n      name: \"Braavos\",\n    },\n  });\n}\n\nexport function injected({ id }: { id: string }): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id,\n    },\n  });\n}\n", "import { goerli, mainnet } from \"@starknet-react/chains\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\nexport type MockConnectorOptions = {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name: string;\n  /** Wallet icons. */\n  icon: ConnectorIcons;\n  /** Whether the connector is available for use. */\n  available?: boolean;\n  /** Whether the connector should fail to connect. */\n  failConnect?: boolean;\n  /** Include account when switching chain. */\n  unifiedSwitchAccountAndChain?: boolean;\n  /** Emit change account event when switching chain. */\n  emitChangeAccountOnChainSwitch?: boolean;\n};\n\nexport type MockConnectorAccounts = {\n  goerli: AccountInterface[];\n  mainnet: AccountInterface[];\n};\n\nexport class MockConnector extends Connector {\n  private _accounts: MockConnectorAccounts;\n  private _accountIndex = 0;\n  private _options: MockConnectorOptions;\n  private _connected = false;\n  private _chainId: bigint = goerli.id;\n\n  constructor({\n    accounts,\n    options,\n  }: { accounts: MockConnectorAccounts; options: MockConnectorOptions }) {\n    super();\n\n    if (accounts.mainnet.length === 0 || accounts.goerli.length === 0) {\n      throw new Error(\"MockConnector: accounts must not be empty\");\n    }\n\n    this._accounts = accounts;\n    this._options = options;\n  }\n\n  switchChain(chainId: bigint): void {\n    this._chainId = chainId;\n    this._accountIndex = 0;\n    let account;\n    if (this._options.unifiedSwitchAccountAndChain) {\n      account = this._account.address;\n    }\n\n    this.emit(\"change\", { chainId, account });\n\n    if (this._options.emitChangeAccountOnChainSwitch ?? true) {\n      this.switchAccount(this._accountIndex);\n    }\n  }\n\n  switchAccount(accountIndex: number): void {\n    this._accountIndex = accountIndex;\n    this.emit(\"change\", { account: this._account.address });\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name;\n  }\n\n  get icon(): ConnectorIcons {\n    return this._options.icon;\n  }\n\n  available(): boolean {\n    return this._options.available ?? true;\n  }\n\n  async chainId(): Promise<bigint> {\n    return this._chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    return this._connected;\n  }\n\n  async connect(): Promise<ConnectorData> {\n    if (this._options.failConnect) {\n      throw new UserRejectedRequestError();\n    }\n\n    this._connected = true;\n\n    return {\n      account: this._account.address,\n      chainId: this._chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this._connected = false;\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._connected) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._account;\n  }\n\n  private get _account(): AccountInterface {\n    let account;\n    if (this._chainId === mainnet.id) {\n      account = this._accounts.mainnet[this._accountIndex];\n    } else {\n      account = this._accounts.goerli[this._accountIndex];\n    }\n\n    if (!account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return account;\n  }\n}\n", "import { Chain, goerli, mainnet, sepolia } from \"@starknet-react/chains\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { constants, AccountInterface, ProviderInterface } from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { ConnectorData } from \"~/connectors/base\";\nimport { ConnectorNotFoundError } from \"~/errors\";\nimport { ChainProviderFactory } from \"~/providers\";\nimport { ExplorerFactory } from \"~/explorers/\";\nimport { AccountProvider } from \"./account\";\n\n/** State of the Starknet context. */\nexport interface StarknetState {\n  /** Connected connector. */\n  connector?: Connector;\n  /** Connect the given connector. */\n  connect: ({ connector }: { connector?: Connector }) => Promise<void>;\n  /** Disconnect the currently connected connector. */\n  disconnect: () => Promise<void>;\n  /** List of registered connectors. */\n  connectors: Connector[];\n  /** Current explorer factory. */\n  explorer?: ExplorerFactory;\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Current chain. */\n  chain: Chain;\n  /** Current provider. */\n  provider: ProviderInterface;\n  /** Error. */\n  error?: Error;\n}\n\nconst StarknetContext = createContext<StarknetState | undefined>(undefined);\n\n/**\n * Returns the current Starknet context state.\n *\n * @remarks\n *\n * This hook should be used sparingly and will be deprecated.\n *\n * Use the following hooks:\n *\n *  - `account`: `useAccount`\n *  - `connect`, `disconnect`, `connectors`: `useConnectors`\n *\n * @example\n * This example shows how to access the Starknet provider.\n * ```tsx\n * function Component() {\n *   const { library } = useStarknet()\n *\n *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>\n *   return <span>Provider URL: {library.provider.baseUrl}</span>\n * }\n * ```\n */\nexport function useStarknet(): StarknetState {\n  const state = useContext(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\",\n    );\n  }\n  return state;\n}\n\ninterface StarknetManagerState {\n  currentChain: Chain;\n  connectors: Connector[];\n  currentAccount?: AccountInterface;\n  currentProvider: ProviderInterface;\n  error?: Error;\n}\n\ninterface UseStarknetManagerProps {\n  chains: Chain[];\n  provider: ChainProviderFactory;\n  explorer?: ExplorerFactory;\n  connectors?: Connector[];\n  autoConnect?: boolean;\n}\n\nfunction useStarknetManager({\n  chains,\n  provider,\n  explorer,\n  connectors = [],\n  autoConnect = false,\n}: UseStarknetManagerProps): StarknetState & { account?: AccountInterface } {\n  const initialChain = chains[0];\n  if (initialChain === undefined) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n\n  const { chain: defaultChain, provider: defaultProvider } = providerForChain(\n    initialChain,\n    provider,\n  );\n\n  // The currently connected connector needs to be accessible from the\n  // event handler.\n  const connectorRef = useRef<Connector | undefined>();\n  const [state, setState] = useState<StarknetManagerState>({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors,\n  });\n\n  const updateChainAndProvider = useCallback(\n    ({ chainId }: { chainId?: bigint }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider,\n          );\n          setState((state) => ({\n            ...state,\n            currentChain: newChain,\n            currentProvider: newProvider,\n          }));\n          return;\n        }\n      }\n    },\n    [setState, chains],\n  );\n\n  const handleConnectorChange = useCallback(\n    async ({ chainId, account }: ConnectorData) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n\n      if (account && connectorRef.current) {\n        const account = await connectorRef.current.account();\n        setState((state) => ({\n          ...state,\n          currentAccount: account,\n        }));\n      }\n    },\n    [updateChainAndProvider, setState, connectorRef],\n  );\n\n  const connect = useCallback(\n    async ({ connector }: { connector?: Connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n      }\n\n      try {\n        const { chainId } = await connector.connect();\n        const account = await connector.account();\n\n        if (account.address !== state.currentAccount?.address) {\n          connectorRef.current = connector;\n          setState((state) => ({\n            ...state,\n            currentAccount: account,\n          }));\n        }\n\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n        }\n\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state) => ({\n          ...state,\n          error: new ConnectorNotFoundError(),\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      setState,\n      connectorRef,\n      state.currentAccount,\n      handleConnectorChange,\n      updateChainAndProvider,\n    ],\n  );\n\n  const disconnect = useCallback(async () => {\n    setState((state) => ({\n      ...state,\n      currentAccount: undefined,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain,\n    }));\n\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n\n    try {\n      await connectorRef.current.disconnect();\n    } catch {}\n    connectorRef.current = undefined;\n  }, [\n    autoConnect,\n    setState,\n    connectorRef,\n    handleConnectorChange,\n    defaultProvider,\n    defaultChain,\n  ]);\n\n  useEffect(() => {\n    async function tryAutoConnect(connectors: Connector[]) {\n      const lastConnectedConnectorId =\n        localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n\n      const lastConnectedConnector = connectors.find(\n        (connector) => connector.id === lastConnectedConnectorId,\n      );\n      if (lastConnectedConnector === undefined) {\n        return;\n      }\n\n      try {\n        if (!(await lastConnectedConnector.ready())) {\n          // Not authorized anymore.\n          return;\n        }\n\n        connect({ connector: lastConnectedConnector });\n      } catch {\n        // no-op\n      }\n    }\n\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n    // Dependencies intentionally omitted since we only want\n    // this executed once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    account: state.currentAccount,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    explorer,\n    connect,\n    disconnect,\n    connectors,\n    chains,\n  };\n}\n\n/** Arguments for `StarknetProvider`. */\nexport interface StarknetProviderProps {\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Provider to use. */\n  provider: ChainProviderFactory;\n  /** List of connectors to use. */\n  connectors?: Connector[];\n  /** Explorer to use. */\n  explorer?: ExplorerFactory;\n  /** Connect the first available connector on page load. */\n  autoConnect?: boolean;\n  /** React-query client to use. */\n  queryClient?: QueryClient;\n  /** Application. */\n  children?: React.ReactNode;\n}\n\n/** Root Starknet context provider. */\nexport function StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  explorer,\n  autoConnect,\n  queryClient,\n  children,\n}: StarknetProviderProps): JSX.Element {\n  const { account, ...state } = useStarknetManager({\n    chains,\n    provider,\n    explorer,\n    connectors,\n    autoConnect,\n  });\n\n  return (\n    <QueryClientProvider client={queryClient ?? new QueryClient()}>\n      <StarknetContext.Provider value={state}>\n        <AccountProvider account={account}>{children}</AccountProvider>\n      </StarknetContext.Provider>\n    </QueryClientProvider>\n  );\n}\n\nfunction providerForChain(\n  chain: Chain,\n  factory: ChainProviderFactory,\n): { chain: Chain; provider: ProviderInterface } {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\n\nexport function starknetChainId(\n  chainId: bigint,\n): constants.StarknetChainId | undefined {\n  switch (chainId) {\n    case mainnet.id:\n      return constants.StarknetChainId.SN_MAIN;\n    case goerli.id:\n      return constants.StarknetChainId.SN_GOERLI;\n    case sepolia.id:\n      return constants.StarknetChainId.SN_SEPOLIA;\n    default:\n      return undefined;\n  }\n}\n", "import React, { useContext } from \"react\";\n\nimport { AccountInterface } from \"starknet\";\n\nconst AccountContext = React.createContext<AccountInterface | undefined>(\n  undefined,\n);\n\nexport function useStarknetAccount() {\n  const account = useContext(AccountContext);\n  return { account };\n}\n\nexport function AccountProvider({\n  account,\n  children,\n}: {\n  account?: AccountInterface;\n  children: React.ReactNode;\n}) {\n  return (\n    <AccountContext.Provider value={account}>\n      {children}\n    </AccountContext.Provider>\n  );\n}\n", "import React from \"react\";\n\nimport { StarknetProvider, StarknetProviderProps } from \"./starknet\";\n\nexport { starknetChainId } from \"./starknet\";\nexport { AccountProvider as OverrideAccount } from \"./account\";\n\nexport type StarknetConfigProps = StarknetProviderProps;\n\nexport function StarknetConfig({ children, ...config }: StarknetConfigProps) {\n  return <StarknetProvider {...config}>{children}</StarknetProvider>;\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the StarkCompassExplorer class that extends Explorer\nexport class StarkCompassExplorer implements Explorer {\n  public name = \"Stark Compass\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"starkCompass\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    return `${this.link}/blocks/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/transactions/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contracts/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/classes/${hash}`;\n  }\n}\n\n// Define the starkcompass factory function\nexport const starkcompass: ExplorerFactory<StarkCompassExplorer> = (\n  chain: Chain,\n) => {\n  return new StarkCompassExplorer(chain);\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the StarkscanExplorer class that extends Explorer\nexport class StarkscanExplorer implements Explorer {\n  public name = \"Starkscan\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"starkscan\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    return `${this.link}/block/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}`;\n  }\n}\n\n// Define the starkscan factory function\nexport const starkscan: ExplorerFactory<StarkscanExplorer> = (chain: Chain) => {\n  return new StarkscanExplorer(chain);\n};\n", "import { goerli, type Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the ViewblockExplorer class that extends Explorer\nexport class ViewblockExplorer implements Explorer {\n  public name = \"Viewblock\";\n  private chainParam: string;\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"viewblock\"]?.toString() ?? \"\";\n    this.chainParam = chain.id === goerli.id ? \"?network=goerli\" : \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    if (hashOrNumber.hash && hashOrNumber.number === undefined) {\n      throw new Error(\n        `The viewblock explorer doesnt support hashes for blocks. Please provide a hash.`,\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.number}${this.chainParam}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}${this.chainParam}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}${this.chainParam}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}${this.chainParam}`;\n  }\n}\n\n// Define the viewblock factory function\nexport const viewblock: ExplorerFactory<ViewblockExplorer> = (chain: Chain) => {\n  return new ViewblockExplorer(chain);\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { Explorer, ExplorerFactory } from \"./explorer\";\n\n// Define the VoyagerExplorer class that extends Explorer\nexport class VoyagerExplorer implements Explorer {\n  public name = \"Voyager\";\n  private link: string;\n\n  constructor(chain: Chain) {\n    this.link = chain.explorers?.[\"voyager\"]?.toString() ?? \"\";\n  }\n\n  block(hashOrNumber: { hash?: string; number?: number }): string {\n    if (hashOrNumber.number !== undefined && hashOrNumber.hash === undefined) {\n      throw new Error(\n        \"The voyager explorer doesn't support numbers for blocks. Please provide a hash.\",\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.hash}`;\n  }\n\n  transaction(hash: string): string {\n    return `${this.link}/tx/${hash}`;\n  }\n\n  contract(address: string): string {\n    return `${this.link}/contract/${address}`;\n  }\n\n  class(hash: string): string {\n    return `${this.link}/class/${hash}`;\n  }\n}\n\n// Define the voyager factory function\nexport const voyager: ExplorerFactory<VoyagerExplorer> = (chain: Chain) => {\n  return new VoyagerExplorer(chain);\n};\n", "import { Chain } from \"@starknet-react/chains\";\nimport { RpcProvider, RpcProviderOptions } from \"starknet\";\n\nimport { starknetChainId } from \"~/context\";\nimport { ChainProviderFactory } from \"./factory\";\n\n/** Arguments for `jsonRpcProvider`. */\nexport type JsonRpcProviderArgs = {\n  rpc: (chain: Chain) => RpcProviderOptions | null;\n};\n\n/** Configure the JSON-RPC provider using the provided function. */\nexport function jsonRpcProvider({\n  rpc,\n}: JsonRpcProviderArgs): ChainProviderFactory<RpcProvider> {\n  return function (chain) {\n    const config = rpc(chain);\n    if (!config) return null;\n    const chainId = starknetChainId(chain.id);\n\n    const provider = new RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Configure the provider to use the public RPC endpoint. */\nexport function publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      // Pick random node from the list of public nodes.\n      const rpcs = chain.rpcUrls.public.http;\n      const nodeUrl = rpcs[Math.floor(Math.random() * rpcs.length)];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `alchemyProvider`. */\nexport type AlchemyProviderArgs = {\n  /** Alchemy API key. */\n  apiKey: string;\n};\n\n/** Configure the Alchemy provider using the provided API key. */\nexport function alchemyProvider({ apiKey }: AlchemyProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `blastProvider`. */\nexport type BlastProviderArgs = {\n  /** Blast API key. */\n  apiKey: string;\n};\n\n/** Configure the Blast provider using the provided API key. */\nexport function blastProvider({ apiKey }: BlastProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"blast\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `infuraProvider`. */\nexport type InfuraProviderArgs = {\n  /** Infura API key. */\n  apiKey: string;\n};\n\n/** Configure the Infura provider using the provided API key. */\nexport function infuraProvider({ apiKey }: InfuraProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `lavaProvider`. */\nexport type LavaProviderArgs = {\n  /** Lava API key. */\n  apiKey: string;\n};\n\n/** Configure the Lava provider using the provided API key. */\nexport function lavaProvider({ apiKey }: LavaProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `nethermindProvider`. */\nexport type NethermindProviderArgs = {\n  /** Nethermind API key. */\n  apiKey: string;\n};\n\n/** Configure the Nethermind provider using the provided API key. */\nexport function nethermindProvider({ apiKey }: NethermindProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"nethermind\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/?apikey=${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `reddioProvider`. */\nexport type ReddioProviderArgs = {\n  /** Reddio API key. */\n  apiKey: string;\n};\n\n/** Configure the Reddio provider using the provided API key. */\nexport function reddioProvider({ apiKey }: ReddioProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"reddio\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n", "import { useCallback, useEffect, useState } from \"react\";\nimport { AccountInterface } from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { useStarknetAccount } from \"~/context/account\";\n\nimport { useConnect } from \"./useConnect\";\n\n/** Arguments for `useAccount` hook. */\nexport type UseAccountProps = {\n  /** Function to invoke when connected. */\n  onConnect?: (args: {\n    address?: UseAccountResult[\"address\"];\n    connector?: UseAccountResult[\"connector\"];\n  }) => void;\n  /** Function to invoke when disconnected. */\n  onDisconnect?: () => void;\n};\n\n/** Account connection status. */\nexport type AccountStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"reconnecting\";\n\n/** Value returned from `useAccount`. */\nexport type UseAccountResult = {\n  /** The connected account object. */\n  account?: AccountInterface;\n  /** The address of the connected account. */\n  address?: string;\n  /** The connected connector. */\n  connector?: Connector;\n  /** Connector's chain id */\n  chainId?: bigint;\n  /** True if connecting. */\n  isConnecting?: boolean;\n  /** True if reconnecting. */\n  isReconnecting?: boolean;\n  /** True if connected. */\n  isConnected?: boolean;\n  /** True if disconnected. */\n  isDisconnected?: boolean;\n  /** The connection status. */\n  status: AccountStatus;\n};\n\n/**\n * Hook for accessing the account and its connection status.\n *\n * @remarks\n *\n * This hook is used to access the `AccountInterface` object provided by the\n * currently connected wallet.\n *\n * @example\n * This example shows how to display the wallet connection status and\n * the currently connected wallet address.\n * ```tsx\n * function Component() {\n *   const { account, address, status } = useAccount()\n *\n *   if (status === 'disconnected') return <p>Disconnected</p>\n *   return <p>Account: {address}</p>\n * }\n * ```\n */\nexport function useAccount({\n  onConnect,\n  onDisconnect,\n}: UseAccountProps = {}): UseAccountResult {\n  const { account: connectedAccount } = useStarknetAccount();\n  const { connectors } = useConnect();\n  const [state, setState] = useState<UseAccountResult>({\n    status: \"disconnected\",\n  });\n\n  const refreshState = useCallback(async () => {\n    if (!connectedAccount) {\n      if (!state.isDisconnected && onDisconnect !== undefined) {\n        onDisconnect();\n      }\n      return setState({\n        status: \"disconnected\",\n        isDisconnected: true,\n        isConnected: false,\n        isConnecting: false,\n        isReconnecting: false,\n      });\n    }\n\n    for (const connector of connectors) {\n      if (!connector.available()) continue;\n\n      // If the connector is not authorized, `.account()` will throw.\n      let connAccount;\n      try {\n        connAccount = await connector.account();\n      } catch {}\n\n      if (connAccount && connAccount?.address === connectedAccount.address) {\n        if (state.isDisconnected && onConnect !== undefined) {\n          onConnect({ address: connectedAccount.address, connector });\n        }\n\n        return setState({\n          connector,\n          chainId: await connector.chainId(),\n          account: connectedAccount,\n          address: connectedAccount.address,\n          status: \"connected\",\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          isReconnecting: false,\n        });\n      }\n    }\n\n    // If we get here, we're not connected to any connector.\n    // This can happen if it's an arcade account.\n    setState({\n      connector: undefined,\n      chainId: undefined,\n      account: connectedAccount,\n      address: connectedAccount.address,\n      status: \"connected\",\n      isConnected: true,\n      isConnecting: false,\n      isDisconnected: false,\n      isReconnecting: false,\n    });\n  }, [\n    setState,\n    connectedAccount,\n    connectors,\n    onConnect,\n    onDisconnect,\n    state.isDisconnected,\n  ]);\n\n  useEffect(() => {\n    refreshState();\n  }, [refreshState]);\n\n  return state;\n}\n", "import { useStarknet } from \"~/context/starknet\";\n\nimport { useCallback } from \"react\";\nimport { Connector } from \"~/connectors/base\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nexport type ConnectVariables = { connector?: Connector };\n\ntype MutationResult = UseMutationResult<void, unknown, ConnectVariables>;\n\nexport type UseConnectProps = UseMutationProps<void, unknown, ConnectVariables>;\n\n/** Value returned from `useConnect`. */\nexport type UseConnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Current connector. */\n  connector?: Connector;\n  /** Connectors available for the current chain. */\n  connectors: Connector[];\n  /** Connector waiting approval for connection. */\n  pendingConnector?: Connector;\n  /** Connect to a new connector. */\n  connect: (args?: ConnectVariables) => void;\n  /** Connect to a new connector. */\n  connectAsync: (args?: ConnectVariables) => Promise<void>;\n};\n\n/**\n * Hook for connecting to a StarkNet wallet.\n *\n * @remarks\n *\n * Use this to implement a \"connect wallet\" component.\n *\n * @example\n * This example shows how to connect a wallet.\n * ```tsx\n * function Component() {\n *   const { connect, connectors } = useConnect();\n *   return (\n *     <ul>\n *     {connectors.map((connector) => (\n *       <li key={connector.id}>\n *         <button onClick={() => connect({ connector })}>\n *           {connector.name}\n *         </button>\n *       </li>\n *     ))}\n *     </ul>\n *   )\n * }\n * ```\n */\nexport function useConnect(props: UseConnectProps = {}): UseConnectResult {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props,\n  });\n\n  const connect = useCallback(\n    (args?: ConnectVariables) => mutate(args ?? { connector }),\n    [mutate, connector],\n  );\n\n  const connectAsync = useCallback(\n    (args?: ConnectVariables) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector],\n  );\n\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result,\n  };\n}\n", "import {\n  QueryKey,\n  UseMutationOptions as UseMutationOptions_,\n  UseMutationResult as UseMutationResult_,\n  UseQueryOptions as UseQueryOptions_,\n  UseQueryResult as UseQueryResult_,\n  useMutation as useMutation_,\n  useQuery as useQuery_,\n} from \"@tanstack/react-query\";\n\nexport type UseQueryProps<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Pick<\n  UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n  \"enabled\" | \"refetchInterval\" | \"retry\" | \"retryDelay\"\n>;\n\nexport type UseQueryResult<TData, TError> = Pick<\n  UseQueryResult_<TData, TError>,\n  | \"data\"\n  | \"error\"\n  | \"status\"\n  | \"isSuccess\"\n  | \"isError\"\n  | \"isPending\"\n  | \"fetchStatus\"\n  | \"isFetching\"\n  | \"isLoading\"\n  | \"refetch\"\n>;\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  args: UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const base = useQuery_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch,\n  };\n}\nexport type UseMutationProps<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationOptions_<TData, TError, TVariables, TContext>,\n  \"onSuccess\" | \"onError\" | \"onMutate\" | \"onSettled\"\n>;\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationResult_<TData, TError, TVariables, TContext>,\n  | \"data\"\n  | \"error\"\n  | \"isError\"\n  | \"isIdle\"\n  | \"isPending\"\n  | \"isPaused\"\n  | \"isSuccess\"\n  | \"reset\"\n  | \"mutate\"\n  | \"mutateAsync\"\n  | \"status\"\n  | \"variables\"\n>;\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = unknown,\n  TContext = unknown,\n>(\n  args: UseMutationOptions_<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const base = useMutation_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables,\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  CallData,\n  ContractInterface,\n  num,\n  shortString,\n  uint256,\n} from \"starknet\";\nimport { z } from \"zod\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\nexport type Balance = {\n  decimals: number;\n  symbol: string;\n  formatted: string;\n  value: bigint;\n};\n\nexport type UseBalanceProps = UseQueryProps<\n  Balance,\n  Error,\n  Balance,\n  ReturnType<typeof queryKey>\n> & {\n  /** The contract's address. Defaults to the native currency. */\n  token?: string;\n  /** The address to fetch balance for. */\n  address?: string;\n  /** Whether to watch for changes. */\n  watch?: boolean;\n};\n\nexport type UseBalanceResult = UseQueryResult<Balance, Error>;\n\nexport function useBalance({\n  token,\n  address,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseBalanceProps) {\n  const { chain } = useNetwork();\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token ?? chain.nativeCurrency.address,\n  });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, token, address }),\n    [chain, contract, token, address],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address],\n  );\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ chain, contract, token, address }),\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  token,\n  address,\n}: {\n  chain: Chain;\n  contract?: ContractInterface;\n  token?: string;\n  address?: string;\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      contract,\n      token,\n      address,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  chain,\n  token,\n  address,\n  contract,\n}: {\n  chain: Chain;\n  token?: string;\n  address?: string;\n  contract?: ContractInterface;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!contract) throw new Error(\"contract is required\");\n\n    let symbolPromise = Promise.resolve(chain.nativeCurrency.symbol);\n    if (token) {\n      symbolPromise = contract.call(\"symbol\", []).then((result) => {\n        const s = symbolSchema.parse(result).symbol;\n        return shortString.decodeShortString(num.toHex(s));\n      });\n    }\n\n    let decimalsPromise = Promise.resolve(chain.nativeCurrency.decimals);\n    if (token) {\n      decimalsPromise = contract.call(\"decimals\", []).then((result) => {\n        return Number(decimalsSchema.parse(result).decimals);\n      });\n    }\n\n    const balanceOfPromise = contract\n      .call(\"balanceOf\", CallData.compile({ address }))\n      .then((result) => {\n        return uint256.uint256ToBN(balanceSchema.parse(result).balance);\n      });\n\n    const [balanceOf, decimals, symbol] = await Promise.all([\n      balanceOfPromise,\n      decimalsPromise,\n      symbolPromise,\n    ]);\n\n    const formatted = (Number(balanceOf) / 10 ** decimals).toString();\n\n    return {\n      value: balanceOf,\n      decimals,\n      symbol,\n      formatted,\n    };\n  };\n}\n\nconst uint256Schema = z.object({\n  low: z.bigint(),\n  high: z.bigint(),\n});\n\nconst balanceSchema = z.object({\n  balance: uint256Schema,\n});\n\nconst decimalsSchema = z.object({\n  decimals: z.bigint(),\n});\n\nconst symbolSchema = z.object({\n  symbol: z.bigint(),\n});\n\nconst balanceABIFragment = [\n  {\n    members: [\n      {\n        name: \"low\",\n        offset: 0,\n        type: \"felt\",\n      },\n      {\n        name: \"high\",\n        offset: 1,\n        type: \"felt\",\n      },\n    ],\n    name: \"Uint256\",\n    size: 2,\n    type: \"struct\",\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"felt\",\n      },\n    ],\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"Uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        name: \"symbol\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        name: \"decimals\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n", "import { useMemo } from \"react\";\nimport { Abi, Contract, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Arguments for `useContract`. */\nexport interface UseContractArgs {\n  /** The contract abi. */\n  abi?: Abi;\n  /** The contract address. */\n  address?: string;\n  /** The provider, by default it will be the current one. */\n  provider?: ProviderInterface | null;\n}\n\n/** Value returned from `useContract`. */\nexport interface UseContractResult {\n  /** The contract. */\n  contract?: Contract;\n}\n\n/**\n * Hook to bind a `Contract` instance.\n *\n * @remarks\n *\n * The returned contract is a starknet.js `Contract` object.\n *\n * @example\n * This example creates a new contract from its address and abi.\n * ```tsx\n * function Component() {\n *   const { contract } = useContract({\n *     address: ethAddress,\n *     abi: compiledErc20.abi\n *   })\n *\n *   return <span>{contract.address}</span>\n * }\n * ```\n */\nexport function useContract({\n  abi,\n  address,\n  provider: providedProvider,\n}: UseContractArgs): UseContractResult {\n  const { provider: currentProvider } = useStarknet();\n\n  const contract = useMemo(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi && address && provider) {\n      return new Contract(abi, address, provider);\n    }\n    return undefined;\n  }, [abi, address, providedProvider, currentProvider]);\n\n  return { contract };\n}\n", "import { QueryKey, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { useBlockNumber } from \"./useBlockNumber\";\n\n/**\n * Invalidate the given query on every new block.\n */\nexport function useInvalidateOnBlock({\n  enabled = true,\n  queryKey,\n}: {\n  enabled?: boolean;\n  queryKey: QueryKey;\n}) {\n  const queryClient = useQueryClient();\n\n  const [prevBlockNumber, setPrevBlockNumber] = useState<number | undefined>();\n\n  const { data: blockNumber } = useBlockNumber({\n    enabled,\n  });\n\n  useEffect(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber]);\n}\n", "import { BlockNumber, BlockTag, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlockNumber`. */\nexport type UseBlockNumberProps = UseQueryProps<\n  number,\n  Error,\n  number,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlockNumber`. */\nexport type UseBlockNumberResult = UseQueryResult<number, Error>;\n\n/**\n * Hook for fetching the current block number.\n *\n * @remarks\n *\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the current block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: false\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block number: {data}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the current block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: 3000\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block Number: {data}</span>\n * }\n * ```\n */\nexport function useBlockNumber({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockNumberProps = {}): UseBlockNumberResult {\n  const { provider } = useStarknet();\n\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    const block = await provider.getBlock(blockIdentifier);\n    return block.block_number;\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useNetwork`. */\nexport type UseNetworkResult = {\n  /** The current chain. */\n  chain: Chain;\n  /** List of supported chains. */\n  chains: Chain[];\n};\n\n/**\n * Hook for accessing the current connected chain.\n *\n * @remarks\n *\n * The network object contains information about the\n * network.\n *\n * @example\n * This example shows how to display the current network name.\n * ```tsx\n * function Component() {\n *   const { chain } = useNetwork()\n *\n *   return <span>{chain.name}</span>\n * }\n */\nexport function useNetwork(): UseNetworkResult {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n", "import {\n  BlockNumber,\n  BlockTag,\n  GetBlockResponse,\n  ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlock`. */\nexport type UseBlockProps = UseQueryProps<\n  GetBlockResponse,\n  Error,\n  GetBlockResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlock`. */\nexport type UseBlockResult = UseQueryResult<GetBlockResponse, Error>;\n\n/**\n * Hook for fetching a block.\n *\n * @remarks\n *\n * Specify which block to fetch with the `blockIdentifier` argument.\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the latest block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: false,\n *     blockIdentifier: 'latest'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the pending block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: 3000,\n *     blockIdentifier: 'pending'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n */\nexport function useBlock({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockProps = {}): UseBlockResult {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"block\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    return await provider.getBlock(blockIdentifier);\n  };\n}\n", "import { useMemo } from \"react\";\nimport { Abi, CompiledContract, ContractFactory } from \"starknet\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractFactory`. */\nexport interface UseContractFactoryProps {\n  /** The compiled contract. */\n  compiledContract?: CompiledContract;\n  /** The class hash  */\n  classHash: string;\n  /** The contract abi. */\n  abi?: Abi;\n}\n\n/** Value returned from `useContractFactory`. */\nexport interface UseContractFactoryResult {\n  /** The contract factory. */\n  contractFactory?: ContractFactory;\n}\n\n/**\n * Hook to create a `ContractFactory`.\n *\n * @remarks\n *\n * The returned contract factory is a starknet.js `ContractFactory` object.\n *\n * This hook works well with `useDeploy`.\n *\n * @example\n * This example shows how to create a contract factory.\n * ```tsx\n * function Component() {\n *   const { contractFactory } = useContractFactory({\n *     compiledContract: compiledErc20,\n *     classHash: erc20ClassHash,\n *     abi: compiledErc20.abi,\n *   })\n *\n *   return <p>Nothing to see here...</p>\n * }\n * ```\n */\nexport function useContractFactory({\n  compiledContract,\n  classHash,\n  abi,\n}: UseContractFactoryProps): UseContractFactoryResult {\n  const { account } = useAccount();\n\n  const contractFactory = useMemo(() => {\n    if (compiledContract && account && classHash) {\n      return new ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi,\n      });\n    }\n    return undefined;\n  }, [compiledContract, classHash, account, abi]);\n\n  return { contractFactory };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  Abi,\n  ArgsOrCalldata,\n  BlockNumber,\n  BlockTag,\n  Contract,\n  Result,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\nconst DEFAULT_FETCH_INTERVAL = 5_000;\n\ntype ContractReadArgs = {\n  /** The contract's function name. */\n  functionName: string;\n  /** Read arguments. */\n  args?: ArgsOrCalldata;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n  /** Parse arguments before passing to contract. */\n  parseArgs?: boolean;\n  /** Parse result after calling contract. */\n  parseResult?: boolean;\n};\n\n/** Options for `useContractRead`. */\nexport type UseContractReadProps = ContractReadArgs &\n  UseQueryProps<Result, Error, Result, ReturnType<typeof queryKey>> & {\n    /** The target contract's ABI. */\n    abi?: Abi;\n    /** The target contract's address. */\n    address?: string;\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useContractRead`. */\nexport type UseContractReadResult = UseQueryResult<Result, Error>;\n\n/**\n * Hook to perform a read-only contract call.\n *\n * @remarks\n *\n * The hook only performs a call if the target `abi`, `address`,\n * `functionName`, and `args` are not undefined.\n */\nexport function useContractRead({\n  abi,\n  address,\n  functionName,\n  args,\n  blockIdentifier = BlockTag.latest,\n  parseArgs,\n  parseResult,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseContractReadProps): UseContractReadResult {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi, address });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, functionName, args, blockIdentifier }),\n    [chain, contract, functionName, args, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args],\n  );\n\n  const refetchInterval =\n    refetchInterval_ ??\n    (blockIdentifier === BlockTag.pending && watch\n      ? DEFAULT_FETCH_INTERVAL\n      : undefined);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult,\n    }),\n    refetchInterval,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n}: { chain?: Chain; contract?: Contract } & ContractReadArgs) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs,\n  parseResult,\n}: { contract?: Contract } & ContractReadArgs) {\n  return async function () {\n    if (!contract) throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === undefined) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier,\n    });\n  };\n}\n", "import { useCallback } from \"react\";\nimport {\n  Abi,\n  AccountInterface,\n  Call,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n} from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractWrite`. */\nexport type ContractWriteVariables = {\n  /** List of smart contract calls to execute. */\n  calls?: Call[];\n  /** Contract ABIs for better displaying. */\n  abis?: Abi[];\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseContractWriteProps = ContractWriteVariables &\n  UseMutationProps<InvokeFunctionResponse, Error, ContractWriteVariables>;\n\nexport type MutationResult = UseMutationResult<\n  InvokeFunctionResponse,\n  Error,\n  ContractWriteVariables\n>;\n\nexport type UseContractWriteResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Execute the calls. */\n  write: (args?: ContractWriteVariables) => void;\n  /** Execute the calls. */\n  writeAsync: (\n    args?: ContractWriteVariables,\n  ) => Promise<InvokeFunctionResponse>;\n};\n\n/**\n * Hook to perform a Starknet multicall.\n *\n * @remarks\n *\n * Multicalls are used to submit multiple transactions in a single\n * call to improve user experience.\n */\nexport function useContractWrite({\n  calls,\n  abis,\n  options,\n  ...props\n}: UseContractWriteProps): UseContractWriteResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ account, calls, abis, options }),\n    mutationFn: mutationFn({ account }),\n    ...props,\n  });\n\n  const write = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutate({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutate, calls, abis, options],\n  );\n\n  const writeAsync = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutateAsync({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutateAsync, calls, abis, options],\n  );\n\n  return {\n    write,\n    writeAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  account,\n  calls,\n  abis,\n  options,\n}: {\n  account?: AccountInterface;\n  calls?: Call[];\n  abis?: Abi[];\n  options?: InvocationsDetails;\n}) {\n  return [{ entity: \"contractWrite\", account, calls, abis, options }] as const;\n}\n\nfunction mutationFn({\n  account,\n}: {\n  account?: AccountInterface;\n}) {\n  return async function ({ calls, abis, options }: ContractWriteVariables) {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return await account?.execute(calls, abis, options);\n  };\n}\n", "import { useStarknet } from \"~/context/starknet\";\nimport { Explorer } from \"~/explorers\";\n\nexport function useExplorer(): Explorer {\n  const { explorer, chain } = useStarknet();\n  if (!explorer)\n    throw Error(\"Explorer is undefined. Try adding it to StarknetConfig.\");\n  const explorerInstance = explorer(chain);\n  if (!explorerInstance) throw Error(\"Explorer Instance is undefined\");\n  return explorerInstance;\n}\n", "import {\n  AccountInterface,\n  BigNumberish,\n  DeployContractResponse,\n  InvocationsDetails,\n  RawArgs,\n} from \"starknet\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\nexport type DeployAccountVariables = {\n  /** The class hash of the contract to deploy. */\n  classHash?: string;\n  /** The constructor arguments. */\n  constructorCalldata?: RawArgs;\n  /** Address salt. */\n  addressSalt?: BigNumberish;\n  /** Contract address. */\n  contractAddress?: string;\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseDeployAccountProps = DeployAccountVariables &\n  UseMutationProps<DeployContractResponse, Error, DeployAccountVariables>;\n\ntype MutationResult = UseMutationResult<\n  DeployContractResponse,\n  Error,\n  DeployAccountVariables\n>;\n\nexport type UseDeployAccountResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Deploy account. */\n  deployAccount: MutationResult[\"mutate\"];\n\n  /** Deploy account. */\n  deployAccountAsync: MutationResult[\"mutateAsync\"];\n};\n\n/**\n * Hook for deploying a contract.\n *\n * @remarks\n *\n * This hook deploys a new contract from the currently connected account.\n */\nexport function useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}: UseDeployAccountProps): UseDeployAccountResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    mutationFn: mutationFn({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    ...props,\n  });\n\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey(\n  props: { account?: AccountInterface } & Partial<DeployAccountVariables>,\n) {\n  return [{ entity: \"deployAccount\", ...props }] as const;\n}\n\nfunction mutationFn({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n}: { account?: AccountInterface } & Partial<DeployAccountVariables>) {\n  return async function () {\n    if (!account) throw new Error(\"account is required\");\n    if (!classHash) throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options,\n    );\n  };\n}\n", "import { useStarknet } from \"~/context/starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\ntype MutationResult = UseMutationResult<void, unknown, void>;\n\nexport type UseDisconnectProps = UseMutationProps<void, unknown, void>;\n\n/** Value returned from `useDisconnect`. */\nexport type UseDisconnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Disconnect wallet. */\n  disconnect: MutationResult[\"mutate\"];\n  /** Disconnect wallet. */\n  disconnectAsync: MutationResult[\"mutateAsync\"];\n};\n\nexport function useDisconnect(\n  props: UseDisconnectProps = {},\n): UseDisconnectResult {\n  const { disconnect, chain } = useStarknet();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props,\n  });\n\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result,\n  };\n}\n", "import { ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useProvider`. */\nexport interface UseProviderResult {\n  /** The current provider. */\n  provider: ProviderInterface;\n}\n\n/**\n * Hook for accessing the current provider.\n *\n * @remarks\n *\n * Use this hook to access the current provider object\n * implementing starknet.js `ProviderInterface`.\n *\n * @example\n * This example shows how to access the current provider.\n * ```tsx\n * function Component() {\n *   const { provider } = useProvider()\n * }\n * ```\n */\nexport function useProvider(): UseProviderResult {\n  const { provider } = useStarknet();\n  return { provider };\n}\n", "import { useCallback } from \"react\";\nimport { AccountInterface, Signature, TypedData } from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\nimport { useAccount } from \"./useAccount\";\n\nexport type SignTypedDataVariables = Partial<TypedData>;\n\ntype MutationResult = UseMutationResult<\n  Signature,\n  Error,\n  SignTypedDataVariables\n>;\n\n/** Arguments for `useSignTypedData` hook. */\nexport type UseSignTypedDataProps = Partial<TypedData> &\n  UseMutationProps<Signature, Error, SignTypedDataVariables>;\n\n/** Value returned by `useSignTypedData` hook. */\nexport type UseSignTypedDataResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  signTypedData: (args?: SignTypedDataVariables) => void;\n  signTypedDataAsync: (args?: SignTypedDataVariables) => Promise<Signature>;\n};\n\nexport function useSignTypedData({\n  domain,\n  types,\n  message,\n  primaryType,\n  ...props\n}: UseSignTypedDataProps): UseSignTypedDataResult {\n  const { account } = useAccount();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ domain, types, message, primaryType }),\n    mutationFn: mutateFn({ account }),\n    ...props,\n  });\n\n  const signTypedData = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutate(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutate, domain, types, message, primaryType],\n  );\n\n  const signTypedDataAsync = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutateAsync(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutateAsync, domain, types, message, primaryType],\n  );\n\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  domain,\n  types,\n  message,\n  primaryType,\n}: Partial<TypedData>) {\n  return [\n    {\n      entity: \"signTypedData\",\n      domain,\n      types,\n      message,\n      primaryType,\n    },\n  ] as const;\n}\n\nfunction mutateFn({ account }: { account?: AccountInterface }) {\n  return function ({\n    domain,\n    types,\n    message,\n    primaryType,\n  }: SignTypedDataVariables): Promise<Signature> {\n    if (!account) throw new Error(\"account is required\");\n    if (!domain) throw new Error(\"domain is required\");\n    if (!types) throw new Error(\"types is required\");\n    if (!message) throw new Error(\"message is required\");\n    if (!primaryType) throw new Error(\"primaryType is required\");\n    return account.signMessage({ domain, types, message, primaryType });\n  };\n}\n", "import { useMemo } from \"react\";\nimport {\n  CallData,\n  Provider,\n  ProviderInterface,\n  RawArgs,\n  starknetId,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useNetwork } from \"./useNetwork\";\n\nexport type UseStarkAddressProps = UseQueryProps<\n  string,\n  Error,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Stark name. */\n  name?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\nexport type UseStarkAddressResult = UseQueryResult<string, Error>;\n\n/**\n * Hook to get the address associated to a stark name.\n *\n * @remarks\n *\n * This hook fetches the address of the specified stark name\n * It defaults to the starknetID contract but a different contract can be targetted by specifying its address\n * If stark name does not have an associated address, it will return \"0x0\"\n *\n * @example\n * This example shows how to get the address associated to a stark name\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching address...</span>\n *   return <span>address: {data}</span>\n * }\n * ```\n */\nexport function useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: UseStarkAddressProps): UseStarkAddressResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n\n  const enabled = useMemo(() => Boolean(enabled_ && name), [enabled_, name]);\n\n  return useQuery({\n    queryKey: queryKey({ name, contract, network: chain.network }),\n    queryFn: queryFn({ name, contract, provider, network: chain.network }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  name,\n  contract,\n  network,\n}: {\n  name?: string;\n  contract?: string;\n  network?: string;\n}) {\n  return [{ entity: \"addressFromStarkName\", name, contract, network }] as const;\n}\n\nfunction queryFn({\n  name,\n  contract,\n  provider,\n  network,\n}: UseStarkAddressProps & { provider: ProviderInterface } & {\n  network: string;\n}) {\n  return async function () {\n    if (!name) throw new Error(\"name is required\");\n\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new Provider(provider);\n    const encodedDomain = decodeDomain(name);\n    const calldata: RawArgs =\n      network === \"mainnet\"\n        ? { domain: encodedDomain }\n        : { domain: encodedDomain, hint: [] };\n    const result = await p.callContract({\n      contractAddress: namingContract as string,\n      entrypoint: \"domain_to_address\",\n      calldata: CallData.compile(calldata),\n    });\n\n    // StarknetID returns 0x0 if no name is found, but that can be dangerous\n    // since we can't expect the user to know that 0x0 is not a valid address.\n    if (BigInt(result.result[0] as string) === BigInt(0))\n      throw new Error(\"Address not found\");\n\n    return result.result[0] as string;\n  };\n}\n\nconst StarknetIdNamingContract: Record<string, string> = {\n  goerli: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n  sepolia: \"0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n};\n\nconst decodeDomain = (domain: string): string[] => {\n  if (!domain) return [\"0\"];\n\n  const encoded = [];\n  for (const subdomain of domain.replace(\".stark\", \"\").split(\".\"))\n    encoded.push(starknetId.useEncoded(subdomain).toString(10));\n  return encoded;\n};\n", "import { useMemo } from \"react\";\nimport { Provider, ProviderInterface } from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useNetwork } from \"./useNetwork\";\n\n/** Arguments for `useStarkName` hook. */\nexport type StarkNameArgs = UseQueryProps<\n  string,\n  unknown,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\n/** Value returned by `useStarkName` hook. */\nexport type StarkNameResult = UseQueryResult<string, unknown>;\n\n/**\n * Hook for fetching Stark name for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address.\n * It defaults to the starknet.id contract but a different contract can be\n * targetted by specifying its contract address\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark name of an address using the default\n * Starknet.id contract\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark name of an address specifying a\n * different contract address\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address, contract: '0x1234' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n */\nexport function useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkNameArgs): StarkNameResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  contract =\n    chain.network === \"sepolia\"\n      ? \"0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2\"\n      : contract;\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, contract }),\n    queryFn: queryFn({ address, contract, provider }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  contract,\n}: {\n  address?: string;\n  contract?: string;\n}) {\n  return [{ entity: \"starkName\", address, contract }] as const;\n}\n\nfunction queryFn({\n  address,\n  contract,\n  provider,\n}: StarkNameArgs & { provider: ProviderInterface }) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n\n    const p = new Provider(provider);\n    return await p.getStarkName(address, contract);\n  };\n}\n", "import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport { GetTransactionReceiptResponse, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\n\n/** Arguments for the `useWaitForTransaction` hook. */\nexport type UseWaitForTransactionProps = UseQueryProps<\n  GetTransactionReceiptResponse,\n  Error,\n  GetTransactionReceiptResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** The transaction hash. */\n  hash?: string;\n  /** Refresh data at every block. */\n  watch?: boolean;\n};\n\nexport type UseWaitForTransactionResult = UseQueryResult<\n  GetTransactionReceiptResponse,\n  Error\n>;\n\n/**\n * Hook to fetch a single transaction receipt.\n *\n * @remarks\n *\n * This hook keeps a cache of receipts by chain and transaction hash\n * so that you can use the hook freely in your application without worrying\n * about sending duplicate network requests.\n *\n * If you need to refresh the transaction receipt data, set `watch: true` in\n * the props. The hook will periodically refresh the transaction data in the\n * background.\n *\n */\nexport function useWaitForTransaction({\n  hash,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}: UseWaitForTransactionProps): UseWaitForTransactionResult {\n  const { provider, chain } = useStarknet();\n\n  const queryKey_ = useMemo(() => queryKey({ chain, hash }), [chain, hash]);\n\n  const enabled = useMemo(() => Boolean(enabled_ && hash), [enabled_, hash]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ provider, hash }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ chain, hash }: { chain?: Chain; hash?: string }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash },\n  ] as const;\n}\n\nfunction queryFn({\n  provider,\n  hash,\n}: {\n  provider: ProviderInterface;\n  hash?: string;\n}) {\n  return async function () {\n    if (!hash) throw new Error(\"hash is required\");\n\n    return await provider.getTransactionReceipt(hash);\n  };\n}\n", "import { useMemo } from \"react\";\nimport {\n  CairoCustomEnum,\n  ContractInterface,\n  Provider,\n  ProviderInterface,\n  cairo,\n  hash,\n  shortString,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useContract } from \"./useContract\";\nimport { useNetwork } from \"./useNetwork\";\n\n/** Arguments for `useStarkProfile` hook. */\nexport type StarkProfileArgs = UseQueryProps<\n  GetStarkprofileResponse,\n  unknown,\n  GetStarkprofileResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Get Starknet ID default pfp url if no profile picture is set */\n  useDefaultPfp?: boolean;\n  /** Naming contract to use. */\n  namingContract?: string;\n  /** Identity contract to use. */\n  identityContract?: string;\n};\n\n/** Value returned by `useStarkProfile` hook. */\ntype GetStarkprofileResponse = {\n  name?: string;\n  /** Metadata url of the NFT set as profile picture. */\n  profile?: string;\n  /** Profile picture url. */\n  profilePicture?: string;\n  twitter?: string;\n  github?: string;\n  discord?: string;\n  proofOfPersonhood?: boolean;\n};\nexport type useStarkProfileResult = UseQueryResult<\n  GetStarkprofileResponse,\n  unknown\n>;\n\n/**\n * Hook for fetching Stark profile for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address, profile picture url,\n * social networks ids, and proof of personhood a user has set on its starknetid.\n * It defaults to the starknet.id naming and identity contracts but different contracts can be\n * targetted by specifying their contract addresses\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark profile of an address using the default\n * Starknet.id contracts\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching stark profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark profile of an address disabling useDefaultPfp and specifying a\n * different naming and identity contract addresses\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address, useDefaultPfp: false, namingContract: '0x1234', identityContract: '0x5678' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n */\nexport function useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkProfileArgs): useStarkProfileResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: (StarknetIdcontracts[chain.network] as any)[\"multicall\"],\n  });\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, namingContract, identityContract }),\n    queryFn: queryFn({\n      address,\n      useDefaultPfp,\n      namingContract,\n      provider,\n      network: chain.network,\n      identityContract,\n      multicallContract,\n    }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  namingContract,\n  identityContract,\n}: {\n  address?: string;\n  namingContract?: string;\n  identityContract?: string;\n}) {\n  return [\n    { entity: \"starkprofile\", address, namingContract, identityContract },\n  ] as const;\n}\n\nfunction queryFn({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  provider,\n  network,\n  multicallContract,\n}: StarkProfileArgs & { provider: ProviderInterface } & { network?: string } & {\n  multicallContract?: ContractInterface;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!multicallContract) throw new Error(\"multicallContract is required\");\n    if (!network) throw new Error(\"network is required\");\n\n    const contracts = StarknetIdcontracts[network] as Record<string, string>;\n    const identity = identityContract ?? (contracts[\"identity\"] as string);\n    const naming = namingContract ?? (contracts[\"naming\"] as string);\n\n    // get decoded starkname\n    const p = new Provider(provider);\n    const name = await p.getStarkName(address, naming);\n\n    const data = await multicallContract.call(\"aggregate\", [\n      [\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n          calldata: [hardcoded(address)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector:\n            network === \"mainnet\"\n              ? hardcoded(hash.getSelectorFromName(\"domain_to_token_id\"))\n              : hardcoded(hash.getSelectorFromName(\"domain_to_id\")),\n          calldata: [arrayReference(0, 0)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"twitter\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"github\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"discord\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"proof_of_personhood\")),\n            hardcoded(contracts[\"verifier_pop\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        // PFP\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_contract\")),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(\n            hash.getSelectorFromName(\"get_extended_verifier_data\")\n          ),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_id\")),\n            hardcoded(\"2\"),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: notEqual(6, 0, 0),\n          to: reference(6, 0),\n          selector: hardcoded(hash.getSelectorFromName(\"tokenURI\")),\n          calldata: [reference(7, 1), reference(7, 2)],\n        },\n      ],\n    ]);\n\n    if (Array.isArray(data)) {\n      const twitter =\n        data[2][0] !== BigInt(0) ? data[2][0].toString() : undefined;\n      const github =\n        data[3][0] !== BigInt(0) ? data[3][0].toString() : undefined;\n      const discord =\n        data[4][0] !== BigInt(0) ? data[4][0].toString() : undefined;\n      const proofOfPersonhood = data[5][0] === BigInt(1) ? true : false;\n\n      const profile =\n        data.length === 9\n          ? data[8]\n              .slice(1)\n              .map((val: BigInt) =>\n                shortString.decodeShortString(val.toString())\n              )\n              .join(\"\")\n          : undefined;\n\n      // extract nft_image from profile data\n      const profilePicture = profile\n        ? await fetchImageUrl(profile)\n        : useDefaultPfp\n        ? `https://starknet.id/api/identicons/${data[1][0].toString()}`\n        : undefined;\n\n      return {\n        name,\n        twitter,\n        github,\n        discord,\n        proofOfPersonhood,\n        profilePicture,\n        profile,\n      };\n    } else {\n      throw new Error(\"Error while fetching data\");\n    }\n  };\n}\n\nconst hardcoded = (arg: string | number) => {\n  return new CairoCustomEnum({\n    Hardcoded: arg,\n  });\n};\n\nconst reference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    Reference: cairo.tuple(call, pos),\n  });\n};\n\nconst arrayReference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    ArrayReference: cairo.tuple(call, pos),\n  });\n};\n\nconst staticExecution = () => {\n  return new CairoCustomEnum({\n    Static: {},\n  });\n};\n\nconst notEqual = (call: number, pos: number, value: number) => {\n  return new CairoCustomEnum({\n    IfNotEqual: cairo.tuple(call, pos, value),\n  });\n};\n\nconst fetchImageUrl = async (url: string): Promise<string> => {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\"Network response was not ok\");\n    }\n\n    const data = await response.json();\n\n    // Check if the \"image\" key exists and is not null\n    if (data.image) {\n      return data.image;\n    } else {\n      return \"Image is not set\";\n    }\n  } catch (error) {\n    console.error(\"There was a problem fetching the image URL:\", error);\n    return \"Error fetching data\";\n  }\n};\n\nconst StarknetIdcontracts: Record<string, Record<string, string>> = {\n  goerli: {\n    naming: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n    identity:\n      \"0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d\",\n    verifier:\n      \"0x019e5204152a72891bf8cd0bed8f03593fdb29ceacd14fca587be5d9fcf87c0e\",\n    verifier_pop:\n      \"0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106\",\n    verifier_pfp:\n      \"0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n  sepolia: {\n    naming: \"0x5847d20f9757de24395a7b3b47303684003753858737bf288716855dfb0aaf2\",\n    identity:\n      \"0x718d9172f6e36183abeeff1a0db76a1851cef4ed9b9c13896da79ef4bfcb4d0\",\n    verifier:\n      \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    verifier_pop:\n      \"0x00f80f68443becd0e0a4a08ff5734e36dd8028507333e4a0ec034dcfdf1b793e\",\n    verifier_pfp:\n      \"0x070c035557d6fed57eed2ed7fa861616b487f8a95439347b805639ca076f29f0\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity:\n      \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier:\n      \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop:\n      \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp:\n      \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n};\n\nconst multicallABI = [\n  {\n    type: \"impl\",\n    name: \"ComposableMulticallImpl\",\n    interface_name: \"composable_multicall::IComposableMulticall\",\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::Execution\",\n    variants: [\n      { name: \"Static\", type: \"()\" },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicFelt\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicCalldata\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"composable_multicall::DynamicCall\",\n    members: [\n      { name: \"execution\", type: \"composable_multicall::Execution\" },\n      { name: \"to\", type: \"composable_multicall::DynamicFelt\" },\n      { name: \"selector\", type: \"composable_multicall::DynamicFelt\" },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"core::array::Span::<core::felt252>\",\n    members: [\n      { name: \"snapshot\", type: \"@core::array::Array::<core::felt252>\" },\n    ],\n  },\n  {\n    type: \"interface\",\n    name: \"composable_multicall::IComposableMulticall\",\n    items: [\n      {\n        type: \"function\",\n        name: \"aggregate\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\",\n          },\n        ],\n        outputs: [\n          { type: \"core::array::Array::<core::array::Span::<core::felt252>>\" },\n        ],\n        state_mutability: \"view\",\n      },\n    ],\n  },\n  {\n    type: \"event\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    kind: \"enum\",\n    variants: [],\n  },\n];\n", "import { Connector } from \"@starknet-react/core\";\nimport { Account, AccountInterface, shortString } from \"starknet\";\nimport { katanaIcon } from \"./icons\";\n\n/** Burner connector options. */\ninterface BurnerConnectorOptions {\n    /** The connector id. */\n    id: string;\n    /** Connector human readable name. */\n    name?: string;\n    /** Connector icons. */\n    icon?: ConnectorIcons;\n}\n\n/** Non exported types from @starknet-react/core*/\n\n/** Connector icons, as base64 encoded svg. */\ntype ConnectorIcons = {\n    /** Dark-mode icon. */\n    dark?: string;\n    /** Light-mode icon. */\n    light?: string;\n};\n/** Connector data. */\ntype ConnectorData = {\n    /** Connector account. */\n    account?: string;\n    /** Connector network. */\n    chainId?: bigint;\n};\n\n/**\n *\n * @class BurnerConnector\n *\n * @description Extends the Connector class and implements the AccountInterface.\n *             This class is used to connect to the Burner Wallet.\n *\n *\n */\nexport class BurnerConnector extends Connector {\n    private _options: BurnerConnectorOptions;\n    private _account: AccountInterface | Account;\n\n    constructor(\n        options: BurnerConnectorOptions,\n        account: AccountInterface | Account\n    ) {\n        super();\n\n        this._options = options;\n        this._account = account;\n    }\n\n    available(): boolean {\n        return true;\n    }\n\n    async ready(): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n\n    async connect(): Promise<ConnectorData> {\n        if (!this._account) {\n            throw new Error(\"account not found\");\n        }\n\n        const chainId = await this.chainId();\n\n        return Promise.resolve({\n            account: this._account.address,\n            chainId,\n        });\n    }\n\n    async disconnect(): Promise<void> {\n        Promise.resolve(this._account == null);\n    }\n\n    async account(): Promise<AccountInterface> {\n        return Promise.resolve(this._account);\n    }\n\n    async chainId(): Promise<bigint> {\n        const chainId = await this._account.getChainId();\n\n        return Promise.resolve(BigInt(shortString.encodeShortString(chainId)));\n    }\n\n    get id(): string {\n        return this._options.id;\n    }\n\n    get name(): string {\n        return this._options.name || \"Dojo Burner\";\n    }\n\n    get icon(): ConnectorIcons {\n        return (\n            this._options.icon || {\n                light: katanaIcon,\n                dark: katanaIcon,\n            }\n        );\n    }\n}\n", "export const katanaIcon =\n    \"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzYgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xOC4yNzk4IDEzLjU4NzNDMTkuNjE5OCAxMy41ODczIDIwLjcwNjEgMTIuNTAwOCAyMC43MDYxIDExLjE2MDVDMjAuNzA2MSA5LjgyMDE3IDE5LjYxOTggOC43MzM2NCAxOC4yNzk4IDguNzMzNjRDMTYuOTM5OCA4LjczMzY0IDE1Ljg1MzUgOS44MjAxNyAxNS44NTM1IDExLjE2MDVDMTUuODUzNSAxMi41MDA4IDE2LjkzOTggMTMuNTg3MyAxOC4yNzk4IDEzLjU4NzNaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNS40MTAxNiAyLjc5NDhIMzEuMTUzOVYzLjg4NTEyQzMxLjE1MzkgNC4wODA0NiAzMS4wNzE4IDQuMjY0MjMgMzAuOTMxMiA0LjM5MzEyTDI4LjYyNiA2LjQ2NDRDMjguMzI1MSA2LjgwMDQxIDI3LjkxMSA2Ljk5MTk0IDI3LjQ4MTIgNi45OTE5NEgyNS42NTI3QzI1LjY1MjcgNi45OTE5NCAyNS42NDg4IDguNTA3NTUgMjUuNjQ4OCA5LjM5MjY1QzI1LjY0ODggMTAuMjc3NiAyNS4yODY1IDExLjIzMzIgMjUuMjg2NSAxMS4yMzMyTDI1LjUzMzQgMTEuNDgwMkMyNS43OTc5IDExLjExNyAyNi45NjY4IDkuNjc2NjQgMjcuNzQzIDkuNjc2NjRMMzAuNjc3MiA5LjY2MTA0VjEzLjQwNDhMMjUuNjQ4OCAxMy40NjM1VjIwLjc5NDhMMjQuNzY5NyAxOS45MTk0QzIzLjc2NzggMTguOTIzMyAyMi43NjQyIDE3LjkyODkgMjEuNzY1MiAxNi45Mjk5VjkuOTE1MDlDMjEuNzY1MiA4Ljg3MDU2IDIxLjk5NjkgOC4wMjA4MiAyMi4yMTAxIDcuMDg3NTlMMjIuMjEwNSA3LjA4NTY4TDIyLjIxMTkgNy4wNzk3NEwyMi4yMTM0IDcuMDczOUMyMi4yMTU0IDcuMDY2NjggMjIuMjE3MSA3LjA2MDMxIDIyLjIxNjcgNy4wNTM0MUMyMi4yMTY0IDcuMDQ3NzggMjIuMjE0NyA3LjA0MTgzIDIyLjIxMDUgNy4wMzQ5M0MyMi4xODQgNi45OTUwMiAyMi4wNzQ3IDYuOTU1MiAyMS45NzA2IDYuOTM1MjRDMjEuODkxIDYuOTIwMDYgMjEuODE0NyA2LjkxNjQ1IDIxLjc4MDggNi45MzMzM0MyMS4yMjMxIDcuMjA1MiAyMC42MzA4IDcuMzA2NjcgMjAuMDE2NiA3LjMxNzEyQzE4Ljg2MDcgNy4zMzY2MyAxNy43MDIgNy4zMzY0NSAxNi41NDYgNy4zMTcxMkMxNS45MzIzIDcuMzA2NjQgMTUuMzQwNCA3LjIwNDk2IDE0Ljc4MzIgNi45MzMzM0MxNC43MDUxIDYuODk0MjYgMTQuNDAwMyA2Ljk2NDU1IDE0LjM1MzUgNy4wMzQ5M0MxNC4zNDE3IDcuMDU0NDcgMTQuMzQ5NSA3LjA2NjE1IDE0LjM1MzUgNy4wODU2OEwxNC4zNTM5IDcuMDg3NTlDMTQuNTY3IDguMDIwNDIgMTQuNzk4OCA4Ljg3OTY5IDE0Ljc5ODggOS45MTUwOVYxNi45Mjk5QzEzLjUwNzQgMTguMjIxMyAxMi4yMDkzIDE5LjUwNiAxMC45MTUyIDIwLjc5NDhWMTMuNDYzNUw1Ljg4Njg0IDEzLjQwNDhWOS42NjEwNEw4LjgyMTAzIDkuNjc2NjRDOS41OTcyMSA5LjY3NjY0IDEwLjc2NjEgMTEuMTE3IDExLjAzMDYgMTEuNDgwMkwxMS4yNzc1IDExLjIzMzJDMTEuMjc3NSAxMS4yMzMyIDEwLjkxNTIgMTAuMjc3NiAxMC45MTUyIDkuMzkyNjVDMTAuOTE1MiA4LjUwNzU1IDEwLjkxMTMgNi45OTE5NCAxMC45MTEzIDYuOTkxOTRIOS4wODI3OEM4LjY1MzAzIDYuOTkxOTQgOC4yMzg4OCA2LjgwMDQxIDcuOTM4MDYgNi40NjQ0TDUuNjMyODQgNC4zOTMxMkM1LjQ5MjIyIDQuMjY0MjMgNS40MTAxNiA0LjA4MDQ2IDUuNDEwMTYgMy44ODUxMlYyLjc5NDhaIiBmaWxsPSIjRkYyRjQyIi8+Cjwvc3ZnPgo=\";\n", "import { IStarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface, RpcProvider } from \"starknet\";\nimport { BurnerManager } from \"..\";\nimport { katanaIcon } from \"./icons\";\n\nconst ID = \"dojoburner\";\nconst NAME = \"Dojo Burner\";\nconst VERSION = \"0.0.1\";\n\nexport class DojoBurnerStarknetWindowObject implements IStarknetWindowObject {\n    id = ID;\n    name = NAME;\n    icon = katanaIcon;\n    account?: AccountInterface = undefined;\n    provider?: RpcProvider = undefined;\n    selectedAddress?: string = undefined;\n    chainId?: string = undefined;\n    isConnected = false;\n    version = VERSION;\n    //\n    burnerManager: BurnerManager;\n\n    constructor(burnerManager: BurnerManager) {\n        if (!burnerManager.isInitialized) {\n            throw new Error(\"burnerManager should be initialized\");\n        }\n\n        this.burnerManager = burnerManager;\n\n        this.chainId = this.burnerManager.chainId;\n        this.provider = this.burnerManager.provider;\n\n        const activeAccount = this.burnerManager.getActiveAccount();\n\n        this.account = activeAccount ? activeAccount : undefined;\n        this.selectedAddress = this.account?.address;\n    }\n\n    ///@ts-ignore\n    async request(call: any) {\n        //console.log(\"request\", call);\n    }\n\n    ///@ts-ignore\n    async enable({ starknetVersion = \"v5\" } = {}) {\n        //console.log(\"enable\");\n        if (!this.burnerManager) {\n            // try to wait\n            await new Promise((r) => setTimeout(r, 1500));\n        }\n\n        // retrieve active account\n        const activeAccount = this.burnerManager?.getActiveAccount();\n        this.account = activeAccount ? activeAccount : undefined;\n\n        if (!this.account) {\n            this.account = await this.burnerManager?.create();\n        }\n        if (!this.account) {\n            this.isConnected = false;\n            return [];\n        }\n\n        this.isConnected = true;\n\n        return [this.account.address];\n    }\n\n    async isPreauthorized() {\n        return true;\n    }\n\n    ///@ts-ignore\n    on = (event: any, handleEvent: any) => {\n        //console.log(\"on\", event);\n    };\n\n    ///@ts-ignore\n    off = (event: any, handleEvent: any) => {\n        //console.log(\"off\", event);\n    };\n\n    /** @returns {string} the connector id */\n    static getId(): string {\n        return ID;\n    }\n\n    /** @returns {string} the connector name */\n    static getName(): string {\n        return NAME;\n    }\n}\n", "import { IStarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface, RpcProvider } from \"starknet\";\nimport { PredeployedManager } from \"..\";\nimport { katanaIcon } from \"./icons\";\n\nconst ID = \"dojopredeployed\";\nconst NAME = \"Dojo Predeployed\";\nconst VERSION = \"0.0.1\";\n\nexport class DojoPredeployedStarknetWindowObject\n    implements IStarknetWindowObject\n{\n    id = ID;\n    name = NAME;\n    icon = katanaIcon;\n    account?: AccountInterface = undefined;\n    provider?: RpcProvider = undefined;\n    selectedAddress?: string = undefined;\n    chainId?: string = undefined;\n    isConnected = false;\n    version = VERSION;\n    //\n    predeployedManager: PredeployedManager;\n\n    constructor(predeployedManager: PredeployedManager) {\n        this.predeployedManager = predeployedManager;\n\n        this.chainId = this.predeployedManager.chainId;\n        this.provider = this.predeployedManager.provider;\n\n        const activeAccount = this.predeployedManager.getActiveAccount();\n\n        this.account = activeAccount ? activeAccount : undefined;\n        this.selectedAddress = this.account?.address;\n    }\n\n    ///@ts-ignore\n    async request(call: any) {\n        //console.log(\"request\", call);\n    }\n\n    ///@ts-ignore\n    async enable({ starknetVersion = \"v5\" } = {}) {\n        //console.log(\"enable\");\n        if (!this.predeployedManager) {\n            // try to wait\n            await new Promise((r) => setTimeout(r, 1500));\n        }\n\n        // retrieve active account\n        const activeAccount = this.predeployedManager?.getActiveAccount();\n        this.account = activeAccount ? activeAccount : undefined;\n\n        if (!this.account) {\n            // try to select first account\n            const predeployed = this.predeployedManager?.list();\n            if (predeployed && predeployed?.length > 0) {\n                //select first\n                this.predeployedManager?.select(predeployed[0].address);\n\n                // retrieve active account\n                const activeAccount =\n                    this.predeployedManager?.getActiveAccount();\n                this.account = activeAccount ? activeAccount : undefined;\n            }\n        }\n\n        if (!this.account) {\n            this.isConnected = false;\n            return [];\n        }\n\n        this.isConnected = true;\n\n        return [this.account.address];\n    }\n\n    async isPreauthorized() {\n        return true;\n    }\n\n    ///@ts-ignore\n    on = (event: any, handleEvent: any) => {\n        //console.log(\"on\", event);\n    };\n\n    ///@ts-ignore\n    off = (event: any, handleEvent: any) => {\n        //console.log(\"off\", event);\n    };\n\n    /** @returns {string} the connector id */\n    static getId(): string {\n        return ID;\n    }\n\n    /** @returns {string} the connector name */\n    static getName(): string {\n        return NAME;\n    }\n}\n", "import { ReactNode, createContext } from \"react\";\nimport { BurnerManagerOptions } from \"../types\";\n\nexport const BurnerContext = createContext<BurnerManagerOptions | null>(null);\n\n/**\n * Props for the BurnerProvider component {@link BurnerProvider}\n */\ninterface BurnerProviderProps {\n    children: ReactNode;\n    initOptions: BurnerManagerOptions;\n}\n\n/**\n * BurnerProvider\n *\n * @description This wraps the entire application in a context provider to allow for access to keep\n *            the burner manager options available to all components. Takes {@link BurnerProviderProps}.\n *\n * ```tsx\n * import { BurnerProvider } from '@dojoengine/create-burner';\n *\n * const initOptions = { ... };\n *\n * const App = () => {\n *    return (\n *       <BurnerProvider initOptions={initOptions}>\n *         <MyApp />\n *      </BurnerProvider>\n * )};\n * ```\n *\n * @param children\n * @param initOptions\n */\n\nexport const BurnerProvider = ({\n    children,\n    initOptions,\n}: BurnerProviderProps): JSX.Element => {\n    return (\n        <BurnerContext.Provider value={initOptions}>\n            {children}\n        </BurnerContext.Provider>\n    );\n};\n", "import { useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerContext } from \"../context\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner, BurnerCreateOptions } from \"../types\";\n\n/**\n * A React hook to manage Burner accounts.\n * This hook exposes methods and properties to manage Burner accounts.\n * You need to use this within a {@link BurnerProvider} context.\n *\n * @example\n * ```tsx\n * import { useBurner } from \"@dojoengine/create-burner\";\n *\n * const MyComponent = () => {\n *   const { list, select, create } = useBurner();\n * const burners = list();\n *\n *   return (\n *     <div>\n *       <button onClick={() => create()}>Create Burner</button>\n *     {burners.map((burner) => (\n *       <button key={burner.address} onClick={() => select(burner.address)}>\n *         Select Burner\n *       </button>\n *    ))}\n *  </div>\n *  );\n * };\n * ```\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurner = () => {\n    const initParams = useContext(BurnerContext);\n\n    if (!initParams) {\n        throw new Error(\"useBurner must be used within a BurnerProvider\");\n    }\n\n    /** Initialize the BurnerManager with the provided options. */\n    const burnerManager = useMemo(\n        () => new BurnerManager(initParams),\n        [initParams]\n    );\n\n    const [account, setAccount] = useState<Account | null>(null);\n    const [count, setCount] = useState(0);\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, initialize the burner manager and set the active account.\n    useEffect(() => {\n        (async () => {\n            await burnerManager.init();\n            setAccount(burnerManager.getActiveAccount());\n            setCount(burnerManager.list().length);\n        })();\n    }, []);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager.list();\n    }, [count]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     *\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setCount(0);\n    }, [burnerManager]);\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @param options - (optional) secret seed and index for deterministic accounts.\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(\n        async (options?: BurnerCreateOptions): Promise<Account> => {\n            burnerManager.setIsDeployingCallback(setIsDeploying);\n            const newAccount = await burnerManager.create(options);\n            setAccount(newAccount);\n            setCount((prev) => prev + 1);\n            return newAccount;\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    id: burner.address,\n                    name: \"Dojo Burner\",\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount());\n        setCount(burnerManager.list().length);\n    }, [burnerManager]);\n\n    /**\n     * Returns a deterministic account addresses based on a seed and index.\n     *\n     * @param options - (optional) account secret seed and index\n     * @returns A deterministic Burner address\n     */\n    const generateAddressFromSeed = useCallback(\n        (options?: BurnerCreateOptions): string => {\n            const { address } = burnerManager.generateKeysAndAddress(options);\n            return address;\n        },\n        [burnerManager]\n    );\n\n    // Expose methods and properties for the consumers of this hook.\n    return {\n        get,\n        list,\n        select,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        count,\n        copyToClipboard,\n        applyFromClipboard,\n        generateAddressFromSeed,\n    };\n};\n", "import { KATANA_ETH_CONTRACT_ADDRESS } from \"@dojoengine/core\";\nimport {\n    Account,\n    CallData,\n    ec,\n    hash,\n    RpcProvider,\n    shortString,\n    stark,\n} from \"starknet\";\nimport {\n    Burner,\n    BurnerCreateOptions,\n    BurnerManagerOptions,\n    BurnerStorage,\n    BurnerKeys,\n} from \"../types\";\nimport Storage from \"../utils/storage\";\nimport { derivePrivateKeyFromSeed } from \"../utils/keyDerivation\";\nimport { prefundAccount } from \"./prefundAccount\";\n\nexport const PREFUND_AMOUNT = \"0x2386f26fc10000\";\n\n/**\n * A class to manage Burner accounts.\n * This class exposes methods and properties to manage Burner accounts.\n * This class uses LocalStorage to store the Burner accounts.\n * You can use this class to build your own Burner Wallet in any js framework.\n *\n * @example\n *\n * ```ts\n * export const createBurner = async () => {\n *     const rpcProvider = new RpcProvider({\n *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,\n *    });\n *\n *  const masterAccount = new Account(\n *      rpcProvider,\n *      import.meta.env.VITE_PUBLIC_MASTER_ADDRESS!,\n *      import.meta.env.VITE_PUBLIC_MASTER_PRIVATE_KEY!,\n *      \"1\"\n *   );\n *\n *   const burnerManager = new BurnerManager({\n *      masterAccount,\n *      accountClassHash: import.meta.env.VITE_PUBLIC_ACCOUNT_CLASS_HASH!,\n *      rpcProvider,\n *   });\n *\n *   try {\n *           await burnerManager.init();\n *           if (burnerManager.list().length === 0) {\n *                 await burnerManager.create();\n *           }\n *       } catch (e) {\n *           console.log(e);\n *       }\n *   }\n *\n *  return {\n *      account: burnerManager.account as Account,\n *      burnerManager,\n *   };\n * };\n *\n *\n */\n\nexport class BurnerManager {\n    public masterAccount: Account;\n    public accountClassHash: string;\n    public feeTokenAddress: string;\n    public provider: RpcProvider;\n    public chainId: string = \"\";\n\n    public account: Account | null = null;\n    public isDeploying: boolean = false;\n    public isInitialized: boolean = false;\n\n    private setIsDeploying?: (isDeploying: boolean) => void;\n    private afterDeploying?: ({\n        account,\n        deployTx,\n    }: {\n        account: Account;\n        deployTx: string;\n    }) => Promise<void>;\n\n    constructor({\n        masterAccount,\n        accountClassHash,\n        feeTokenAddress = KATANA_ETH_CONTRACT_ADDRESS,\n        rpcProvider,\n    }: BurnerManagerOptions) {\n        this.masterAccount = masterAccount;\n        this.accountClassHash = accountClassHash;\n        this.feeTokenAddress = feeTokenAddress;\n        this.provider = rpcProvider;\n    }\n\n    public setIsDeployingCallback(\n        callback: (isDeploying: boolean) => void\n    ): void {\n        this.setIsDeploying = callback;\n    }\n\n    public setAfterDeployingCallback(\n        callback: ({\n            account,\n            deployTx,\n        }: {\n            account: Account;\n            deployTx: string;\n        }) => Promise<void>\n    ): void {\n        this.afterDeploying = callback;\n    }\n\n    private updateIsDeploying(status: boolean) {\n        this.isDeploying = status;\n        if (this.setIsDeploying) {\n            this.setIsDeploying(status);\n        }\n    }\n\n    private getBurnerKey(): string {\n        return `burners_${this.chainId}`;\n    }\n\n    private getBurnerStorage(): BurnerStorage {\n        return Storage.get(this.getBurnerKey()) || {};\n    }\n\n    private setActiveBurnerAccount(storage: BurnerStorage): void {\n        for (let address in storage) {\n            if (storage[address].active) {\n                this.account = new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n                return;\n            }\n        }\n    }\n\n    private async isBurnerDeployed(deployTx: string): Promise<boolean> {\n        try {\n            const receipt =\n                await this.masterAccount.getTransactionReceipt(deployTx);\n            return receipt !== null;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    public async init(keepNonDeployed = false): Promise<void> {\n        if (this.isInitialized) {\n            throw new Error(\"BurnerManager is already initialized\");\n        }\n        this.chainId = shortString.decodeShortString(\n            (await this.provider.getChainId()) as string\n        );\n        const storage = this.getBurnerStorage();\n        const addresses = Object.keys(storage);\n\n        const checks = addresses.map(async (address) => {\n            const isDeployed = await this.isBurnerDeployed(\n                storage[address].deployTx\n            );\n            return isDeployed ? null : address;\n        });\n\n        const toRemove = (await Promise.all(checks)).filter(\n            (address): address is string => address !== null\n        );\n\n        toRemove.forEach((address) => {\n            if (!keepNonDeployed) {\n                console.log(\n                    `Removing non-deployed burner at address ${address}.`\n                );\n                delete storage[address];\n            }\n        });\n\n        if (Object.keys(storage).length) {\n            Storage.set(this.getBurnerKey(), storage);\n            this.setActiveBurnerAccount(storage); // Re-select the active burner account\n        } else {\n            this.clear();\n        }\n\n        this.isInitialized = true;\n    }\n\n    public list(): Burner[] {\n        const storage = this.getBurnerStorage();\n        return Object.keys(storage).map((address) => {\n            return {\n                address,\n                active: storage[address].active,\n                masterAccount: storage[address].masterAccount,\n                accountIndex: storage[address].accountIndex,\n            };\n        });\n    }\n\n    public select(address: string): void {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        storage[address].active = true;\n\n        Storage.set(this.getBurnerKey(), storage);\n        this.account = new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public deselect(): void {\n        const storage = this.getBurnerStorage();\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        Storage.set(this.getBurnerKey(), storage);\n        this.account = null;\n    }\n\n    public get(address: string): Account {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        return new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public delete(address: string) {\n        const storage = this.getBurnerStorage();\n        if (!storage[address]) {\n            throw new Error(\"burner not found\");\n        }\n\n        delete storage[address];\n\n        Storage.set(this.getBurnerKey(), storage);\n    }\n\n    clear(): void {\n        Storage.remove(this.getBurnerKey());\n    }\n\n    getActiveAccount(): Account | null {\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            if (storage[address].active) {\n                return new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n            }\n        }\n        return null;\n    }\n\n    public generateKeysAndAddress(options?: BurnerCreateOptions): BurnerKeys {\n        const privateKey = options?.secret\n            ? derivePrivateKeyFromSeed(options.secret, options.index || 0)\n            : stark.randomAddress();\n        const publicKey = ec.starkCurve.getStarkKey(privateKey);\n        return {\n            privateKey,\n            publicKey,\n            address: hash.calculateContractAddressFromHash(\n                publicKey,\n                this.accountClassHash,\n                CallData.compile({ publicKey }),\n                0\n            ),\n        };\n    }\n\n    public async create(options?: BurnerCreateOptions): Promise<Account> {\n        if (!this.isInitialized) {\n            throw new Error(\"BurnerManager is not initialized\");\n        }\n\n        this.updateIsDeploying(true);\n\n        const { privateKey, publicKey, address } =\n            this.generateKeysAndAddress(options);\n\n        if (!this.masterAccount) {\n            throw new Error(\"wallet account not found\");\n        }\n        try {\n            await prefundAccount(\n                address,\n                this.masterAccount,\n                this.feeTokenAddress,\n                options?.prefundedAmount || PREFUND_AMOUNT\n            );\n        } catch (e) {\n            console.error(`burner manager create() error:`, e);\n            this.updateIsDeploying(false);\n        }\n\n        const accountOptions = {\n            classHash: this.accountClassHash,\n            constructorCalldata: CallData.compile({ publicKey }),\n            addressSalt: publicKey,\n        };\n\n        // deploy burner\n        const burner = new Account(this.provider, address, privateKey, \"1\");\n\n        let deployTx = \"\";\n        try {\n            const nonce = await this.account?.getNonce();\n            const { transaction_hash } = await burner.deployAccount(\n                accountOptions,\n                {\n                    nonce,\n                    maxFee: 0, // TODO: update\n                }\n            );\n            deployTx = transaction_hash;\n        } catch (error) {\n            this.updateIsDeploying(false);\n            throw error;\n        }\n\n        // check if account is already deployed\n        let isDeployed = false;\n        try {\n            isDeployed = await this.isBurnerDeployed(deployTx);\n        } catch {}\n\n        // wait to deploy\n        if (!isDeployed) {\n            const receipt = await this.masterAccount.waitForTransaction(\n                deployTx,\n                {\n                    retryInterval: 100,\n                }\n            );\n            if (!receipt) {\n                throw new Error(\"Transaction did not complete successfully.\");\n            }\n        }\n\n        const storage = this.getBurnerStorage();\n        for (let address in storage) {\n            storage[address].active = false;\n        }\n\n        storage[address] = {\n            chainId: this.chainId,\n            privateKey,\n            publicKey,\n            deployTx,\n            masterAccount: this.masterAccount.address,\n            active: true,\n        };\n\n        if (options?.secret) {\n            storage[address].accountIndex = options.index;\n        }\n        if (options?.metadata) {\n            storage[address].metadata = options.metadata;\n        }\n\n        this.account = burner;\n        this.updateIsDeploying(false);\n        Storage.set(this.getBurnerKey(), storage);\n\n        if (this.afterDeploying) {\n            try {\n                await this.afterDeploying({ account: this.account, deployTx });\n            } catch (e: any) {\n                console.log(\"error on afterDeploying\", e);\n            }\n        }\n\n        return burner;\n    }\n\n    public async copyBurnersToClipboard(): Promise<void> {\n        const burners = this.getBurnerStorage();\n        try {\n            await navigator.clipboard.writeText(JSON.stringify(burners));\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    public async setBurnersFromClipboard(): Promise<void> {\n        try {\n            const text = await navigator.clipboard.readText();\n            const burners: BurnerStorage = JSON.parse(text);\n\n            // Assume no burner is active\n            let activeAddress: string | null = null;\n\n            // Iterate over the pasted burners to find the active one\n            for (const [address, burner] of Object.entries(burners)) {\n                if (burner.active) {\n                    activeAddress = address;\n                    break;\n                }\n            }\n\n            Storage.set(this.getBurnerKey(), burners);\n\n            // If there's an active burner, select it\n            if (activeAddress) {\n                this.select(activeAddress);\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n", "import Cookies from \"js-cookie\";\n\nconst hasLocalStorageSupport = (): boolean => {\n    try {\n        const testKey = \"__test__\";\n        if (typeof window !== \"undefined\") {\n            window.localStorage.setItem(testKey, testKey);\n            window.localStorage.removeItem(testKey);\n            return true;\n        }\n    } catch (e) {\n        return false;\n    }\n    return false;\n};\n\nconst isLocalStorage = hasLocalStorageSupport();\n\nconst safeParse = (data: string): any => {\n    try {\n        if (data === \"\") return null;\n        return JSON.parse(data);\n    } catch (e) {\n        console.error(\"Error parsing JSON data:\", e, \"Data:\", data);\n        return null;\n    }\n};\n\nconst Storage = {\n    keys: (): string[] => {\n        if (isLocalStorage) {\n            return Object.keys(window.localStorage);\n        }\n        return Object.keys(Cookies.get());\n    },\n\n    get: (key: string): any => {\n        if (isLocalStorage) {\n            return safeParse(window.localStorage.getItem(key) || \"\");\n        }\n        return safeParse(Cookies.get(key) || \"\");\n    },\n\n    set: (key: string, value: any): void => {\n        const data = JSON.stringify(value);\n        if (isLocalStorage) {\n            window.localStorage.setItem(key, data);\n        } else {\n            Cookies.set(key, data, {\n                secure: true,\n                sameSite: \"strict\",\n            });\n        }\n    },\n\n    remove: (key: string): void => {\n        if (isLocalStorage) {\n            window.localStorage.removeItem(key);\n        } else {\n            Cookies.remove(key);\n        }\n    },\n\n    clear: (): void => {\n        if (isLocalStorage) {\n            window.localStorage.clear();\n        } else {\n            const cookies = Cookies.get();\n            Object.keys(cookies).forEach((key) => Cookies.remove(key));\n        }\n    },\n};\n\nexport default Storage;\n", "import { ec, encode, num } from \"starknet\";\nimport { HDKey } from \"@scure/bip32\";\n\n//\n// inspired by:\n// https://community.starknet.io/t/account-keys-and-addresses-derivation-standard/1230\n// https://github.com/argentlabs/argent-x/blob/main/packages/extension/src/background/keys/keyDerivation.ts\n// https://github.com/amanusk/starknet-cli-wallet/blob/main/src/keyDerivation.ts\n//\n// BIP-32 Hierarchical Deterministic Wallets\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n//\n\nfunction getPathForIndex(index: number): string {\n    return `m/44'/9004'/0'/0/${index}`;\n}\n\n/**\n * @description derive an account KeyPair from a secret hash and index, allowing deterministic account creation\n * @param {string} secret a secret hash, like the signature of a message signed on the client, never stored!\n * @param {number} index sequential number identifying the account\n * @returns {KeyPair} the account address (pubKey) and private key (getPrivateKey)\n **/\nexport function derivePrivateKeyFromSeed(\n    secret: string,\n    index: number\n): string {\n    if (!secret) {\n        throw \"seed is undefined\";\n    }\n    const masterNode = HDKey.fromMasterSeed(num.hexToBytes(secret));\n    const childNode = masterNode.derive(getPathForIndex(index));\n    if (!childNode.privateKey) {\n        throw \"childNode.privateKey is undefined\";\n    }\n    const groundKey = ec.starkCurve.grindKey(childNode.privateKey);\n    return encode.addHexPrefix(groundKey);\n}\n", "import {\n    AccountInterface,\n    CallData,\n    TransactionFinalityStatus,\n} from \"starknet\";\n\n/**\n * Pre-funds a given account by initiating a transfer transaction.\n *\n * @param address - The destination address to which funds are to be transferred.\n * @param account - The source account from which funds will be deducted.\n * @param feeTokenAddress - The Ethereum contract address responsible for the transfer.\n *                             If not provided, defaults to KATANA_ETH_CONTRACT_ADDRESS.\n *\n * @returns - Returns the result of the transfer transaction, typically including transaction details.\n *\n * @throws - Throws an error if the transaction does not complete successfully.\n */\nexport const prefundAccount = async (\n    address: string,\n    account: AccountInterface,\n    feeTokenAddress: string,\n    prefundAmount: string\n): Promise<any> => {\n    try {\n        // Configure the options for the transfer transaction\n        const transferOptions = {\n            contractAddress: feeTokenAddress,\n            entrypoint: \"transfer\",\n            calldata: CallData.compile([address, prefundAmount, \"0x0\"]),\n        };\n\n        // Retrieve the nonce for the account to avoid transaction collisions\n        const nonce = await account.getNonce();\n        // Initiate the transaction\n        const { transaction_hash } = await account.execute(\n            [transferOptions],\n            undefined,\n            {\n                nonce,\n                maxFee: 0, // This is set to 0 for now, consider adjusting it based on network conditions or requirements.\n            }\n        );\n\n        // Wait for the transaction to complete and check its status\n        const result = await account.waitForTransaction(transaction_hash, {\n            retryInterval: 1000,\n            successStates: [TransactionFinalityStatus.ACCEPTED_ON_L2],\n        });\n\n        if (!result) {\n            throw new Error(\"Transaction did not complete successfully.\");\n        }\n\n        return result;\n    } catch (error) {\n        console.error(error);\n        throw error;\n    }\n};\n", "import { useCallback, useEffect, useState } from \"react\";\nimport { Account } from \"starknet\";\nimport { BurnerConnector } from \"..\";\nimport { BurnerManager } from \"../manager/burnerManager\";\nimport { Burner, BurnerCreateOptions } from \"../types\";\n\n/**\n * A React hook that takes the Burner Manager object avoiding the React Context.\n * Useful for building apps without React Context.\n *\n * @returns An object with utility methods and properties.\n */\nexport const useBurnerManager = ({\n    burnerManager,\n}: {\n    burnerManager: BurnerManager; // Accepts the BurnerManager class as an parameter\n}) => {\n    const [isError, setIsError] = useState(false);\n\n    // State to manage the current active account.\n    const [account, setAccount] = useState<Account | null>(null);\n    const [count, setCount] = useState(0);\n    const [isDeploying, setIsDeploying] = useState(false);\n\n    // On mount, set the active account and count the number of burners.\n    // burnerManager has to be initialized before the component mounts\n    useEffect(() => {\n        // allow null burner manager\n        // when the game rpc is unavailable, its impossible to create a valid Burner Manager and will result in client error\n        if (!burnerManager) {\n            setIsError(true);\n            console.error(\"BurnerManager object must be provided\");\n            return;\n        }\n        if (!burnerManager.isInitialized) {\n            throw new Error(\"BurnerManager must be intialized\");\n        }\n        if (!burnerManager.masterAccount) {\n            throw new Error(\"BurnerManager Master Account must be provided\");\n        }\n        setIsError(false);\n        (async () => {\n            setAccount(burnerManager.getActiveAccount());\n            setCount(burnerManager.list().length);\n        })();\n    }, [burnerManager]);\n\n    /**\n     * Lists all the burners available in the storage.\n     *\n     * @returns An array of Burner accounts.\n     */\n    const list = useCallback((): Burner[] => {\n        return burnerManager?.list() ?? [];\n    }, [count]);\n\n    /**\n     * Selects and sets a burner as the active account.\n     *\n     * @param address - The address of the burner account to set as active.\n     */\n    const select = useCallback(\n        (address: string): void => {\n            burnerManager.select(address);\n            setAccount(burnerManager.getActiveAccount());\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Deselects the active burner, account will be set to null. Useful to allow guests.\n     */\n    const deselect = useCallback((): void => {\n        burnerManager.deselect();\n        setAccount(null);\n    }, [burnerManager]);\n\n    /**\n     * Retrieves a burner account based on its address.\n     *\n     * @param address - The address of the burner account to retrieve.\n     * @returns The Burner account corresponding to the provided address.\n     */\n    const get = useCallback(\n        (address: string): Account => {\n            return burnerManager.get(address);\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Deletes a burner account based on its address.\n     *\n     * @param address - The address of the burner account to delete.\n     */\n    const remove = useCallback(\n        (address: string): void => {\n            burnerManager.delete(address);\n            setCount((prev) => Math.max(prev - 1, 0));\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Clears a burner account based on its address.\n     */\n    const clear = useCallback(() => {\n        burnerManager.clear();\n        setCount(0);\n    }, [burnerManager]);\n\n    /**\n     * Creates a new burner account and sets it as the active account.\n     *\n     * @param options - (optional) secret seed and index for deterministic accounts.\n     * @returns A promise that resolves to the newly created Burner account.\n     */\n    const create = useCallback(\n        async (options?: BurnerCreateOptions): Promise<Account> => {\n            burnerManager.setIsDeployingCallback(setIsDeploying);\n            const newAccount = await burnerManager.create(options);\n            setAccount(newAccount);\n            setCount((prev) => prev + 1);\n            return newAccount;\n        },\n        [burnerManager]\n    );\n\n    /**\n     * Generates a list of BurnerConnector instances for each burner account. These can be added to Starknet React.\n     *\n     * @returns An array of BurnerConnector instances.\n     */\n    const listConnectors = useCallback((): BurnerConnector[] => {\n        // Retrieve all the burners.\n        const burners = list();\n\n        // Map each burner to its respective BurnerConnector instance.\n        return burners.map((burner) => {\n            return new BurnerConnector(\n                {\n                    id: burner.address,\n                    name: \"Dojo Burner\",\n                },\n                get(burner.address)\n            );\n        });\n    }, [burnerManager?.isDeploying]);\n\n    /**\n     * Copy burners to clipboard\n     */\n    const copyToClipboard = useCallback(async () => {\n        await burnerManager.copyBurnersToClipboard();\n    }, [burnerManager]);\n\n    /**\n     * Set burners from clipboard\n     */\n    const applyFromClipboard = useCallback(async () => {\n        await burnerManager.setBurnersFromClipboard();\n        setAccount(burnerManager.getActiveAccount());\n        setCount(burnerManager.list().length);\n    }, [burnerManager]);\n\n    /**\n     * Returns a deterministic account addresses based on a seed and index.\n     *\n     * @param options - (optional) account secret seed and index\n     * @returns A deterministic Burner address\n     */\n    const generateAddressFromSeed = useCallback(\n        (options?: BurnerCreateOptions): string => {\n            const { address } = burnerManager.generateKeysAndAddress(options);\n            return address;\n        },\n        [burnerManager]\n    );\n\n    return {\n        isError,\n        get,\n        list,\n        select,\n        deselect,\n        remove,\n        create,\n        listConnectors,\n        clear,\n        account,\n        isDeploying,\n        count,\n        copyToClipboard,\n        applyFromClipboard,\n        generateAddressFromSeed,\n    };\n};\n", "import { StarknetWindowObject } from \"get-starknet-core\";\nimport { useEffect, useState } from \"react\";\nimport { BurnerManager, DojoBurnerStarknetWindowObject } from \"..\";\n\nexport const useBurnerWindowObject = (burnerManager?: BurnerManager) => {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const [isError, setIsError] = useState(false);\n    const [error, setError] = useState<string | undefined>();\n\n    useEffect(() => {\n        const initAsync = async () => {\n            if (!burnerManager) {\n                setIsInitialized(true);\n                return;\n            }\n\n            try {\n                if (!burnerManager.isInitialized) {\n                    await burnerManager.init();\n                }\n\n                const starknetWindowObject = new DojoBurnerStarknetWindowObject(\n                    burnerManager\n                );\n\n                const key = `starknet_${starknetWindowObject.id}`;\n                (window as any)[key] =\n                    starknetWindowObject as StarknetWindowObject;\n\n                setIsInitialized(true);\n            } catch (e: any) {\n                console.log(e);\n                setIsError(true);\n                setError(\"failed to initialize burnerManager\");\n            }\n        };\n\n        initAsync();\n    }, [burnerManager]);\n\n    return { isInitialized, isError, error };\n};\n", "import { StarknetWindowObject } from \"get-starknet-core\";\nimport { useEffect, useState } from \"react\";\nimport { DojoPredeployedStarknetWindowObject, PredeployedManager } from \"..\";\n\nexport const usePredeployedWindowObject = (\n    predeployedManager?: PredeployedManager\n) => {\n    const [isInitialized, setIsInitialized] = useState(false);\n    const [isError, setIsError] = useState(false);\n    const [error, setError] = useState<string | undefined>();\n\n    useEffect(() => {\n        const initAsync = async () => {\n            if (!predeployedManager) {\n                setIsInitialized(true);\n                return;\n            }\n\n            try {\n                if (!predeployedManager.isInitialized) {\n                    await predeployedManager.init();\n                }\n\n                const starknetWindowObject =\n                    new DojoPredeployedStarknetWindowObject(predeployedManager);\n\n                const key = `starknet_${starknetWindowObject.id}`;\n                (window as any)[key as string] =\n                    starknetWindowObject as StarknetWindowObject;\n\n                setIsInitialized(true);\n            } catch (e: any) {\n                console.log(e);\n                setIsError(true);\n                setError(\"failed to initialize predeployedManager\");\n            }\n        };\n\n        initAsync();\n    }, [predeployedManager]);\n\n    return { isInitialized, isError, error };\n};\n", "import { Account, RpcProvider, shortString } from \"starknet\";\nimport {\n    Predeployed,\n    PredeployedAccount,\n    PredeployedManagerOptions,\n    PredeployedStorage,\n} from \"../types\";\nimport Storage from \"../utils/storage\";\n\n/**\n * A class to manage Predeployed accounts.\n * This class exposes methods and properties to manage Predeployed accounts.\n * This class uses LocalStorage to store the Predeployed accounts.\n *\n * @example\n *\n * ```ts\n * export const createPredeployed = async () => {\n *     const rpcProvider = new RpcProvider({\n *          nodeUrl: import.meta.env.VITE_PUBLIC_NODE_URL!,\n *    });\n *\n *   const predeployedManager = new PredeployedManager({\n *      rpcProvider,\n *      predeployedAccounts: [\n *       {\n *           name: \"Deployer\",\n *           address: \"0x6162896d1d7ab204c7ccac6dd5f8e9e7c25ecd5ae4fcb4ad32e57786bb46e03\",\n *           privateKey: \"0x1800000000300000180000000000030000000000003006001800006600\",\n *           active: true\n *       },\n *       {\n *           name: \"Treasury\",\n *           address: \"0xe29882a1fcba1e7e10cad46212257fea5c752a4f9b1b1ec683c503a2cf5c8a\",\n *           privateKey: \"0x14d6672dcb4b77ca36a887e9a11cd9d637d5012468175829e9c6e770c61642\",\n *           active: false\n *       }\n *      ]\n *   });\n *\n *\n *  await predeployedManager.init();\n *\n *  return predeployedManager\n * };\n *\n *\n */\n\nexport class PredeployedManager {\n    public provider: RpcProvider;\n    public chainId: string = \"\";\n\n    public account: Account | null = null;\n    public predeployedAccounts: PredeployedAccount[] = [];\n    public isInitialized: boolean = false;\n\n    constructor({\n        rpcProvider,\n        predeployedAccounts,\n    }: PredeployedManagerOptions) {\n        this.provider = rpcProvider;\n        this.predeployedAccounts = predeployedAccounts;\n    }\n\n    private getStorageKey(): string {\n        return `predeployed_${this.chainId}`;\n    }\n\n    private getStorage(): PredeployedStorage {\n        return Storage.get(this.getStorageKey()) || {};\n    }\n\n    private setActiveAccount(storage: PredeployedStorage): void {\n        for (let address in storage) {\n            if (storage[address].active) {\n                this.account = new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n                return;\n            }\n        }\n    }\n\n    public async init(): Promise<void> {\n        this.chainId = shortString.decodeShortString(\n            (await this.provider.getChainId()) as string\n        );\n\n        const storage = this.getStorage();\n        const addresses = Object.keys(storage);\n\n        if (addresses.length) {\n            Storage.set(this.getStorageKey(), storage);\n            this.setActiveAccount(storage); // Re-select the active account\n        } else {\n            // set predeployed accounts in storage\n            const storage = this.getStorage();\n            for (let predeployed of this.predeployedAccounts) {\n                storage[predeployed.address] = predeployed;\n            }\n            Storage.set(this.getStorageKey(), storage);\n        }\n\n        this.isInitialized = true;\n    }\n\n    public list(): Predeployed[] {\n        const storage = this.getStorage();\n        return Object.keys(storage).map((address) => {\n            return {\n                address,\n                name: storage[address].name,\n                active: storage[address].active,\n            };\n        });\n    }\n\n    public select(address: string): void {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        for (let addr in storage) {\n            storage[addr].active = false;\n        }\n        storage[address].active = true;\n\n        Storage.set(this.getStorageKey(), storage);\n        this.account = new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public get(address: string): Account {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        return new Account(\n            this.provider,\n            address,\n            storage[address].privateKey,\n            \"1\"\n        );\n    }\n\n    public delete(address: string) {\n        const storage = this.getStorage();\n        if (!storage[address]) {\n            throw new Error(\"predeployed not found\");\n        }\n\n        delete storage[address];\n\n        Storage.set(this.getStorageKey(), storage);\n    }\n\n    clear(): void {\n        Storage.remove(this.getStorageKey());\n    }\n\n    getActiveAccount(): Account | null {\n        const storage = this.getStorage();\n        for (let address in storage) {\n            if (storage[address].active) {\n                return new Account(\n                    this.provider,\n                    address,\n                    storage[address].privateKey,\n                    \"1\"\n                );\n            }\n        }\n        return null;\n    }\n}\n", "/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\nexport { api as default };\n", "import { HashMD } from './_md.js';\nimport { rotl, wrapConstructor } from './utils.js';\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));\n\nconst shifts = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  else if (group === 1) return (x & y) | (~x & z);\n  else if (group === 2) return (x | ~y) ^ z;\n  else if (group === 3) return (x & z) | (y & ~z);\n  else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) R_BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean() {\n    R_BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n", "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n", "/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { bytes as assertBytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { createBase58check } from '@scure/base';\n\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\n\nfunction bytesToNumber(bytes: Uint8Array): bigint {\n  return BigInt(`0x${bytesToHex(bytes)}`);\n}\n\nfunction numberToBytes(num: bigint): Uint8Array {\n  return hexToBytes(num.toString(16).padStart(64, '0'));\n}\n\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number) => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions?: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array | bigint;\n}\n\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this.privKeyBytes || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n\n  public static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    assertBytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        `HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32),\n    });\n  }\n\n  public static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  public readonly versions: Versions;\n  public readonly depth: number = 0;\n  public readonly index: number = 0;\n  public readonly chainCode: Uint8Array | null = null;\n  public readonly parentFingerprint: number = 0;\n  private privKey?: bigint;\n  private privKeyBytes?: Uint8Array;\n  private pubKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode || null;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey =\n        typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n\n  public derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      const m1 = m && m[1];\n      if (!m || m.length !== 3 || typeof m1 !== 'string') {\n        throw new Error(`Invalid child index: ${c}`);\n      }\n      let idx = +m1;\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  public deriveChild(index: number): HDKey {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(new Uint8Array([0]), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this.pubKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    try {\n      // Private parent key -> private child key\n      if (this.privateKey) {\n        const added = mod(this.privKey! + childTweak, secp.CURVE.n);\n        if (!secp.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  public sign(hash: Uint8Array): Uint8Array {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    assertBytes(hash, 32);\n    return secp.sign(hash, this.privKey!).toCompactRawBytes();\n  }\n\n  public verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    assertBytes(hash, 32);\n    assertBytes(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = secp.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return secp.verify(sig, hash, this.publicKey);\n  }\n\n  public wipePrivateData(): this {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  public toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    assertBytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "import_jsx_runtime", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "React", "import_react", "import_jsx_runtime", "converter", "z", "bytes", "import_react", "ID", "NAME", "VERSION", "activeAccount", "Account", "shortString", "ec", "CallData", "address", "useState", "useEffect", "useCallback", "PredeployedManager", "storage"]
}
