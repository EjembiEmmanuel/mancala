{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/arrays.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/deferred.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/mobx.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/guards.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/proxy.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/enums.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/objects.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/random.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/rx.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/uuid.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/sleep.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/promise.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/iterable.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/area.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/worker.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/pack.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/CoordMap.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/VoxelCoordMap.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/eth.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/cubic.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/console.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/distance.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/math.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/v2/arrayToHex.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/v2/bytesToString.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/v2/isHex.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/v2/hexToArray.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/v2/stringToBytes.ts", "../../node_modules/.pnpm/@latticexyz+utils@2.0.12/node_modules/@latticexyz/utils/src/bytes.ts"],
  "sourcesContent": ["/**\n * TypeScript type guard to assert the type of a non-empty array\n * @param array Any array to check for non-emptiness\n * @returns True if the empty is non-empty, else false. TypeScript accepts the array as non-empty after the assertion.\n */\nexport function isNotEmpty<T>(array: T[]): array is [T, ...T[]] {\n  if (array.length === 0) return false;\n  return true;\n}\n\n/**\n * Filters undefined values from an array and lets TypeScript know the resulting array\n * does not have undefined values\n * @param array Array potentially including undefined values\n * @returns Array without undefined values\n */\nexport function filterNullishValues<T>(array: (T | undefined)[]): T[] {\n  return array.filter((value) => value != null) as T[];\n}\n", "/**\n * A convenient way to create a promise with resolve and reject functions.\n * @returns Tuple with resolve function, reject function and promise.\n */\nexport function deferred<T>(): [(t: T) => void, (t: Error) => void, Promise<T>] {\n  let resolve: ((t: T) => void) | null = null;\n  let reject: ((t: Error) => void) | null = null;\n  const promise = new Promise<T>((r, rj) => {\n    resolve = (t: T) => r(t);\n    reject = (e: Error) => rj(e);\n  });\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return [resolve as any, reject as any, promise];\n}\n", "import { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport { deferred } from \"./deferred\";\n\n/**\n * @param comp Computed/Observable value that is either defined or undefined\n * @returns promise that resolves with the first truthy computed value\n */\nexport async function awaitValue<T>(comp: IComputedValue<T | undefined> | IObservableValue<T | undefined>): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n\n  const dispose = reaction(\n    () => comp.get(),\n    (value) => {\n      if (value) {\n        resolve(value);\n      }\n    },\n    { fireImmediately: true },\n  );\n\n  const value = await promise;\n  // Dispose the reaction once the promise is resolved\n  dispose();\n\n  return value;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Func } from \"./types\";\n\nexport function isObject(c: unknown): c is Record<string, any> {\n  return typeof c === \"object\" && !Array.isArray(c) && c !== null;\n}\n\nexport function isFunction(c: unknown): c is Func<any, any> {\n  return c instanceof Function;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { IComputedValue, IObservableValue, reaction } from \"mobx\";\nimport DeepProxy from \"proxy-deep\";\nimport { deferred } from \"./deferred\";\nimport { isFunction, isObject } from \"./guards\";\nimport { Cached } from \"./types\";\n\nfunction deepAccess(target: Record<string, unknown>, path: string[]): any {\n  if (path.length === 0) return target;\n  if (path.length === 1) return target[path[0]];\n  const [next, ...rest] = path;\n  const nextTarget = target[next];\n  if (!isObject(nextTarget)) throw new Error(\"Path does not exist on the target\");\n  return deepAccess(nextTarget, rest);\n}\n\n/**\n * Caches any function calls to the target until the target is ready.\n * @param target T extends Cachable\n * @returns Cached<T>\n */\nexport function cacheUntilReady<T extends Record<string, any>>(\n  target: IObservableValue<T | undefined> | IComputedValue<T | undefined>,\n): Cached<T> {\n  // The call queue contains the path and arguments of calls to the\n  // proxiedTarget while the target was not available yet.\n  // It also contains resolve and reject methods to fulfil the promise\n  // returned when calling the proxiedTarget once the target becomes available.\n  const callQueue: {\n    path: string[];\n    args?: any[];\n    resolve: (result: any) => void;\n    reject: (e: Error) => void;\n  }[] = [];\n\n  // The proxiedTarget proxies all calls to the target.\n  // If a function is called on the proxiedTarget while the target is not\n  // available, a promise is returned and the call will be stored in the callQueue\n  // until the target becomes available and the promise is fulfilled.\n  const proxiedTarget = new DeepProxy(\n    {},\n    {\n      get(_t, prop) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          // (Except for the \"proxied\" key, which indicates whether the object is currently proxied)\n          if (prop === \"proxied\") return false;\n          return Reflect.get(targetReady, prop);\n        } else {\n          // Note: if the target is not available, accessing a property returns another proxy,\n          // not a Promise. It is possible to check whether a value is currently proxied using the proxied key.\n          if (prop === \"proxied\") return true;\n          if (prop === \"name\") return \"ProxiedTarget\";\n          if (prop === \"toJSON\") return () => ({ proxied: true });\n          return this.nest(() => void 0);\n        }\n      },\n      apply(_, thisArg, args) {\n        const targetReady = target.get();\n        if (targetReady) {\n          // If the target is ready, relay all calls directly to the target\n          const targetFunc = deepAccess(targetReady, this.path);\n          if (!isFunction(targetFunc)) throw new Error(\"Target is not callable\");\n          return Reflect.apply(targetFunc, thisArg, args);\n        } else {\n          // Otherwise store the call and relay it to the target later once it's ready.\n          // The return value of this call is a promise, that gets resolved once the target is ready.\n          const [resolve, reject, promise] = deferred();\n          callQueue.push({ path: this.path, args, resolve, reject });\n          return promise;\n        }\n      },\n    },\n  );\n\n  reaction(\n    () => target.get(),\n    (targetReady) => {\n      if (!targetReady) return;\n      // Move all entries from callQueue to queuedCalls\n      const queuedCalls = callQueue.splice(0);\n      for (const { path, args, resolve, reject } of queuedCalls) {\n        const target = deepAccess(targetReady, path);\n        if (args && isFunction(target)) {\n          (async () => {\n            try {\n              resolve(await target(...args));\n            } catch (e: any) {\n              reject(e);\n            }\n          })();\n        } else {\n          resolve(target);\n        }\n      }\n    },\n  );\n\n  return proxiedTarget as Cached<T>;\n}\n", "/**\n * @param enm Numeric enum\n * @returns Number array containing the enum values\n */\nexport function numValues(enm: object): number[] {\n  const nums: number[] = [];\n  for (const val of Object.values(enm)) {\n    if (!isNaN(Number(val))) {\n      nums.push(Number(val));\n    }\n  }\n  return nums;\n}\n", "/**\n * Utility function to map a source object to an object with the same keys but mapped values\n * @param source Source object to be mapped\n * @param valueMap Mapping values of the source object to values of the target object\n * @returns An object with the same keys as the source object but mapped values\n */\nexport function mapObject<S extends { [key: string]: unknown }, T extends { [key in keyof S]: unknown }>(\n  source: S,\n  valueMap: (value: S[keyof S], key: keyof S) => T[keyof S],\n): T {\n  const target: Partial<{ [key in keyof typeof source]: T[keyof S] }> = {};\n  for (const key in source) {\n    target[key] = valueMap(source[key], key);\n  }\n  return target as T;\n}\n", "/**\n *\n * @param to Upper bound (included)\n * @param from Lower bound (included). Default 0.\n * @returns A random integer between from and to.\n */\nexport function random(to: number, from = 0): number {\n  return Math.floor(Math.random() * (to - from + 1)) + from;\n}\n\n/**\n * @param array Array to pick a random element from.\n * @returns Random element from the given array.\n */\nexport function pickRandom<T>(array: [T, ...T[]]): T {\n  return array[random(array.length - 1)];\n}\n", "import {\n  concatMap,\n  delay,\n  filter,\n  first,\n  mergeMap,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n  ReplaySubject,\n  scan,\n  Timestamp,\n  timestamp,\n} from \"rxjs\";\nimport { computed, IComputedValue, IObservableValue, observable, reaction, runInAction, toJS } from \"mobx\";\nimport { deferred } from \"./deferred\";\nimport { awaitValue } from \"./mobx\";\n\nexport function filterNullish<T>(): OperatorFunction<T, NonNullable<T>> {\n  return pipe<Observable<T>, Observable<NonNullable<T>>>(\n    filter<T>((x: T) => x != null) as OperatorFunction<T, NonNullable<T>>,\n  );\n}\n\nexport function awaitPromise<T extends Promise<unknown>>(): OperatorFunction<T, Awaited<T>> {\n  return pipe(concatMap((x: T) => x)) as OperatorFunction<T, Awaited<T>>;\n}\n\n/**\n * RxJS operator to stretch out an event stream by a given delay per event\n * @param spacingDelayMs Delay between each event in ms\n * @returns stream of events with at least spacingDelayMs spaceing between event\n */\nexport function stretch<T>(spacingDelayMs: number) {\n  return pipe(\n    timestamp<T>(),\n    scan((acc: (Timestamp<T> & { delay: number }) | null, curr: Timestamp<T>) => {\n      // calculate delay needed to offset next emission\n      let delay = 0;\n      if (acc !== null) {\n        const timeDelta = curr.timestamp - acc.timestamp;\n        delay = timeDelta > spacingDelayMs ? 0 : spacingDelayMs - timeDelta;\n      }\n\n      return {\n        timestamp: curr.timestamp,\n        delay: delay,\n        value: curr.value,\n      };\n    }, null),\n    filterNullish(),\n    mergeMap((i) => of(i.value).pipe(delay(i.delay)), 1),\n  );\n}\n\nexport function observableToComputed<T>(obs: IObservableValue<T>): IComputedValue<T> {\n  return computed(() => obs.get());\n}\n\nexport function computedToStream<T>(comp: IComputedValue<T> | IObservableValue<T>): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => comp.get(),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true },\n  );\n  return stream;\n}\n\nexport function observableToStream<T>(obs: T): Observable<T> {\n  const stream = new ReplaySubject<T>(1);\n  reaction(\n    () => toJS(obs),\n    (value) => {\n      if (value != null) stream.next(value);\n    },\n    { fireImmediately: true },\n  );\n  return stream;\n}\n\nexport function streamToComputed<T>(stream$: Observable<T>): IComputedValue<T | undefined> {\n  const value = observable.box<T | undefined>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  return computed(() => value.get());\n}\n\nexport async function streamToDefinedComputed<T>(stream$: Observable<T>): Promise<IComputedValue<T>> {\n  const value = observable.box<T>();\n  stream$.subscribe((val) => runInAction(() => value.set(val)));\n  const computedValue = computed(() => value.get());\n  await awaitValue(computedValue);\n  return computedValue as IComputedValue<T>;\n}\n\n/**\n *\n * @param stream$ RxJS observable to check for the given value\n * @param predicate Predicate to check\n * @returns A promise that resolves with the requested value once the predicate is true\n */\nexport async function awaitStreamValue<T>(\n  stream$: Observable<T>,\n  predicate: (value: T) => boolean = (value) => value != null,\n): Promise<T> {\n  const [resolve, , promise] = deferred<T>();\n  stream$.pipe(first(predicate)).subscribe(resolve);\n  return promise;\n}\n\n/**\n * Turns a stream into an updating object for easy access outside of rxjs\n * @param stream$ Stream to turn into a wrapped value\n * @returns Object with `current` key corresponding to last stream value\n */\nexport async function streamToWrappedValue<T>(stream$: Observable<T>): Promise<{ current: T }> {\n  const value: { current?: T } = {};\n  stream$.subscribe((v) => (value.current = v));\n  value.current = await awaitStreamValue(stream$);\n  return value as { current: T };\n}\n", "/**\n * UUID.core.js - UUID.js for Minimalists\n *\n * @file\n * @author  LiosK\n * @version v4.2.0\n * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK\n * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js\n */\n\n/**\n * @class\n * @classdesc {@link UUID} object.\n * @hideconstructor\n */\n\n// Core Component {{{\n\n/**\n * Generates a version 4 UUID as a hexadecimal string.\n * @returns {string} Hexadecimal UUID string.\n */\nexport const uuid = function () {\n  const rand = _getRandomInt,\n    hex = _hexAligner;\n  return (\n    hex(rand(32), 8) + // time_low\n    \"-\" +\n    hex(rand(16), 4) + // time_mid\n    \"-\" +\n    hex(0x4000 | rand(12), 4) + // time_hi_and_version\n    \"-\" +\n    hex(0x8000 | rand(14), 4) + // clock_seq_hi_and_reserved clock_seq_low\n    \"-\" +\n    hex(rand(48), 12)\n  ); // node\n};\n\n/**\n * Returns an unsigned x-bit random integer.\n * @private\n * @param {number} x Unsigned integer ranging from 0 to 53, inclusive.\n * @returns {number} Unsigned x-bit random integer (0 <= f(x) < 2^x).\n */\nconst _getRandomInt = function (x: number) {\n  if (x < 0 || x > 53) {\n    return NaN;\n  }\n  const n = 0 | (Math.random() * 0x40000000); // 1 << 30\n  return x > 30 ? n + (0 | (Math.random() * (1 << (x - 30)))) * 0x40000000 : n >>> (30 - x);\n};\n\n/**\n * Converts an integer to a zero-filled hexadecimal string.\n * @private\n * @param {number} num\n * @param {number} length\n * @returns {string}\n */\nconst _hexAligner = function (num: number, length: number) {\n  let str = num.toString(16),\n    i = length - str.length,\n    z = \"0\";\n  for (; i > 0; i >>>= 1, z += z) {\n    if (i & 1) {\n      str = z + str;\n    }\n  }\n  return str;\n};\n", "export function sleep<T>(timeout: number, returns?: T): Promise<T> {\n  return new Promise<T>((resolve) => setTimeout(() => resolve(returns as T), timeout));\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { deferred } from \"./deferred\";\nimport { sleep } from \"./sleep\";\n\nexport const range = function* (total = 0, step = 1, from = 0) {\n  // eslint-disable-next-line no-empty\n  for (let i = 0; i < total; yield from + i++ * step) {}\n};\n\nexport async function rejectAfter<T>(ms: number, msg: string): Promise<T> {\n  await sleep(ms);\n  throw new Error(msg);\n}\n\nexport const timeoutAfter = async <T>(promise: Promise<T>, ms: number, timeoutMsg: string) => {\n  return Promise.race([promise, rejectAfter<T>(ms, timeoutMsg)]);\n};\n\nexport const callWithRetry = <T>(\n  fn: (...args: any[]) => Promise<T>,\n  args: any[] = [],\n  maxRetries = 10,\n  retryInterval = 1000,\n): Promise<T> => {\n  const [resolve, reject, promise] = deferred<T>();\n  const process = async () => {\n    let res: T;\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        res = await fn(...args);\n        resolve(res);\n        break;\n      } catch (e) {\n        if (i < maxRetries - 1) {\n          console.info(\"[CallWithRetry Failed] attempt number=\" + i, fn);\n          console.error(e);\n          await sleep(Math.min(retryInterval * 2 ** i + Math.random() * 100, 15000));\n        } else {\n          reject(e as unknown as Error);\n        }\n      }\n    }\n  };\n  process();\n  return promise;\n};\n", "export function makeIterable<T>(iterator: Iterator<T>): IterableIterator<T> {\n  const iterable: IterableIterator<T> = {\n    ...iterator,\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n\n  return iterable;\n}\n\nexport function concatIterators<T>(first: Iterator<T>, second?: Iterator<T>): IterableIterator<T> {\n  if (!second) return makeIterable(first);\n  return makeIterable({\n    next() {\n      const next = first.next();\n      if (!next.done) return next;\n      return second.next();\n    },\n  });\n}\n\nexport function mergeIterators<A, B>(iteratorA: Iterator<A>, iteratorB: Iterator<B>): IterableIterator<[A, B]> {\n  const iterator: Iterator<[A, B]> = {\n    next() {\n      const nextA = iteratorA.next();\n      const nextB = iteratorB.next();\n      if (nextA.done && nextB.done) return { done: true, value: null };\n      return { value: [nextA.value, nextB.value] };\n    },\n  };\n  return makeIterable(iterator);\n}\n\nexport function transformIterator<A, B>(iterator: Iterator<A>, transform: (value: A) => B): IterableIterator<B> {\n  return makeIterable({\n    next() {\n      const { done, value } = iterator.next();\n      return { done, value: done ? value : transform(value) };\n    },\n  });\n}\n\n/**\n * Turns an array into an iterator. NOTE: an iterator can only be iterated once.\n * @param array Array to be turned into an iterator\n * @returns Iterator to iterate through the array\n */\nexport function arrayToIterator<T>(array: T[]): IterableIterator<T> {\n  let i = 0;\n  const iterator: Iterator<T> = {\n    next() {\n      const done = i >= array.length;\n      if (done) return { done, value: null };\n      return { value: array[i++] };\n    },\n  };\n  return makeIterable(iterator);\n}\n", "import { Area, Coord } from \"./types\";\n\nexport function areaContains(area: Area, coord: Coord) {\n  return coord.x >= area.x && coord.y >= area.y && coord.x < area.x + area.width && coord.y < area.y + area.height;\n}\n\nexport function coordsOf(area: Area) {\n  const coords: Coord[] = [];\n  for (let dx = 0; dx < area.width; dx++) {\n    for (let dy = 0; dy < area.height; dy++) {\n      coords.push({ x: area.x + dx, y: area.y + dy });\n    }\n  }\n  return coords;\n}\n", "import { fromEvent, map, Observable } from \"rxjs\";\n\nexport interface DoWork<In, Out> {\n  work(input$: Observable<In>): Observable<Out>;\n}\n\nexport function fromWorker<I, O>(worker: Worker, input$: Observable<I>): Observable<O> {\n  input$.subscribe((event) => worker.postMessage(event));\n  return fromEvent<MessageEvent<O>>(worker, \"message\").pipe(map((e) => e.data));\n}\n\nexport function runWorker<I, O>(worker: DoWork<I, O>) {\n  const input$ = fromEvent<MessageEvent<I>>(self, \"message\");\n  const output$ = worker.work(input$.pipe(map((event) => event.data)));\n  output$.subscribe((event) => self.postMessage(event));\n}\n", "function rightMask(input: number, keep: number): number {\n  return input & (2 ** keep - 1);\n}\n\n/**\n * Packs two unsigned integers in one 32 bit unsigned integer\n * @param numbers Unsigned integers to be packed in 32 bit integer\n * @param bitsPerNumber Bits for each number\n * @returns Packed 32 bit unsigned integer\n */\nexport function pack(numbers: number[], bitsPerNumber: number[]): number {\n  // Total number of bits must be 32\n  if (bitsPerNumber.reduce((acc, curr) => acc + curr, 0) > 32) {\n    throw new Error(\"JS pretends integers are 32 bit when bitshifts are involved\");\n  }\n\n  // Array lengths must match\n  if (numbers.length !== bitsPerNumber.length) throw new Error(\"Arrays' lengths must match\");\n\n  // Numbers must fit in number of bits and must be unsigned\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < 0) {\n      throw new Error(\"Underflow: can only pack unsigned integer\");\n    }\n    if (numbers[i] > 2 ** bitsPerNumber[i] - 1) {\n      const error = `Overflow: ${numbers[i]} does not fit in ${bitsPerNumber[i]} bits`;\n      throw new Error(error);\n    }\n  }\n\n  // Pack number\n  let packed = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    packed = (packed << bitsPerNumber[i]) | numbers[i];\n  }\n  return packed;\n}\n\n/**\n * Unpacks a packed 32 bit unsigned integer into the original unsigned integers\n * @param packed Packed 32 bit unsigned integer\n * @param bitsPerNumber Bits for each unsigned integer\n * @returns Array of unpacked unsignd integers\n */\nexport function unpack(packed: number, bitsPerNumber: number[]): number[] {\n  const numbers: number[] = [];\n  let shiftedPacked = packed;\n  for (let i = bitsPerNumber.length - 1; i >= 0; i--) {\n    numbers.unshift(rightMask(shiftedPacked, bitsPerNumber[i]));\n    shiftedPacked = shiftedPacked >>> bitsPerNumber[i];\n  }\n  return numbers;\n}\n\nexport function packTuple(numbers: [number, number]): number {\n  return pack(numbers, [8, 24]);\n}\n\nexport function unpackTuple(packed: number): [number, number] {\n  return unpack(packed, [8, 24]) as [number, number];\n}\n", "import { Coord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nconst LOWER_HALF_MASK = 2 ** 16 - 1;\nconst MAX_SUPPORTED = 2 ** 15 - 1;\n\nexport function subtract(from: CoordMap<boolean>, subtract: CoordMap<boolean>): CoordMap<boolean> {\n  const result = new CoordMap<boolean>();\n\n  for (const coord of from.coords()) {\n    if (subtract.get(coord)) continue;\n    result.set(coord, true);\n  }\n\n  return result;\n}\n\nexport function coordToKey(coord: Coord) {\n  const key = (coord.x << 16) | (coord.y & LOWER_HALF_MASK);\n  return key;\n\n  // Old version using strings:\n  // return `${coord.x}/${coord.y}`;\n}\n\nexport function keyToCoord(key: number): Coord {\n  const x = key >> 16;\n  const y = (key << 16) >> 16;\n  return { x, y };\n\n  // Old version using strings:\n  // const fragments = key.split(\"/\");\n  // return { x: Number(fragments[0]), y: Number(fragments[1]) };\n}\n\nexport class CoordMap<T> {\n  map: Map<number, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<number, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<number, T>; defaultValue?: T }): CoordMap<T> {\n    const coordMap = new CoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: Coord, value: T) {\n    if (\n      coord.x > MAX_SUPPORTED ||\n      coord.x < -1 * MAX_SUPPORTED ||\n      coord.y > MAX_SUPPORTED ||\n      coord.y < -1 * MAX_SUPPORTED\n    ) {\n      throw new Error(`CoordMap only supports coords up to ${MAX_SUPPORTED}`);\n    }\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: Coord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<Coord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [Coord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: Coord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: Coord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n", "import { VoxelCoord } from \"./types\";\nimport { transformIterator } from \"./iterable\";\n\nfunction coordToKey(coord: VoxelCoord) {\n  // TODO: find a more memory efficient way to store these keys\n  return `${coord.x}/${coord.y}/${coord.z}`;\n}\n\nfunction keyToCoord(key: string): VoxelCoord {\n  const fragments = key.split(\"/\");\n  return { x: Number(fragments[0]), y: Number(fragments[1]), z: Number(fragments[2]) };\n}\n\nexport class VoxelCoordMap<T> {\n  map: Map<string, T>;\n  defaultValue?: T;\n\n  constructor(props?: { defaultValue?: T }) {\n    this.map = new Map<string, T>();\n    this.defaultValue = props?.defaultValue;\n  }\n\n  static from<T>(coordMapLike: { map: Map<string, T>; defaultValue?: T }): VoxelCoordMap<T> {\n    const coordMap = new VoxelCoordMap<T>();\n    coordMap.map = coordMapLike.map;\n    coordMap.defaultValue = coordMapLike.defaultValue;\n    return coordMap;\n  }\n\n  set(coord: VoxelCoord, value: T) {\n    return this.map.set(coordToKey(coord), value);\n  }\n\n  get(coord: VoxelCoord) {\n    return this.map.get(coordToKey(coord)) ?? this.defaultValue;\n  }\n\n  keys() {\n    return this.map.keys();\n  }\n\n  coords(): IterableIterator<VoxelCoord> {\n    return transformIterator(this.map.keys(), (key) => keyToCoord(key));\n  }\n\n  entries() {\n    return this.map.entries();\n  }\n\n  toArray(): [VoxelCoord, T][] {\n    const entries = Array.from(this.map.entries());\n    return entries.map(([key, value]) => [keyToCoord(key), value]);\n  }\n\n  values() {\n    return this.map.values();\n  }\n\n  delete(coord: VoxelCoord) {\n    return this.map.delete(coordToKey(coord));\n  }\n\n  has(coord: VoxelCoord): boolean {\n    return this.map.has(coordToKey(coord));\n  }\n\n  clear() {\n    for (const key of this.map.keys()) {\n      this.map.delete(key);\n    }\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n}\n", "/**\n * Pads start of a hex string with 0 to create a bit string of the given length\n * @param input Hex string\n * @param bits Number of bits in the output hex string\n * @returns Hex string of specified length\n */\nexport function padToBitLength(input: string, bits: number) {\n  // Cut off 0x prefix\n  if (input.substring(0, 2) == \"0x\") input = input.substring(2);\n  // Pad start with 0 to get desired bit length\n  const length = bits / 4;\n  input = input.padStart(length, \"0\");\n  input = input.substring(input.length - length);\n  // Prefix with 0x\n  return `0x${input}`;\n}\n\n/**\n * Pads start of a hex string with 0 to create a 160 bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 160 bit hex string\n */\nexport function toEthAddress(input: string) {\n  return padToBitLength(input, 160);\n}\n\n/**\n * Pads start of a hex string with 0 to create a 256bit hex string\n * which can be used as an Ethereum address\n * @param input Hex string\n * @returns 256 bit hex string\n */\nexport function to256BitString(input: string) {\n  return padToBitLength(input, 256);\n}\n\nexport function extractEncodedArguments(input: string) {\n  // Cutting off the first 4 bytes, which represent the function selector\n  if (input[0] !== \"0\" && input[1] !== \"x\") throw new Error(\"Invalid hex string\");\n  return \"0x\" + input.substring(10);\n}\n", "const RND_A = 134775813;\nconst RND_B = 1103515245;\nconst ACCURACY = 1000;\n\nexport function randomize(seed: number, x: number, y: number) {\n  return (((((x ^ y) * RND_A) ^ (seed + x)) * (((RND_B * x) << 16) ^ (RND_B * y - RND_A))) >>> 0) / 4294967295;\n}\n\nexport function tile(coordinate: number, period: number) {\n  if (coordinate < 0) while (coordinate < 0) coordinate += period;\n  return coordinate % period;\n}\n\nexport function interpolate(a: number, b: number, c: number, d: number, x: number, s: number, scale: number) {\n  const p = d - c - (a - b);\n  return (b * Math.pow(s, 3) + x * (c * Math.pow(s, 2) + a * s * (-s + x) + x * (-(b + p) * s + p * x))) * scale;\n\n  // return (x) * ((x ) * ((x ) * p + (a - b - p)) + (c - a)) + b;\n}\n\n/**\n * Config a cubic noise.\n * @param {Number} seed A seed in the range [0, 1].\n * @param {Number} [periodX] The number of units after which the x coordinate repeats.\n * @param {Number} [periodY] The number of units after which the y coordinate repeats.\n * @returns {Object} A configuration object used by noise functions.\n */\nexport function cubicNoiseConfig(\n  seed: number,\n  octave: number,\n  scale: number,\n  periodX = Number.MAX_SAFE_INTEGER,\n  periodY = Number.MAX_SAFE_INTEGER,\n) {\n  return {\n    seed: Math.floor(seed * Number.MAX_SAFE_INTEGER),\n    periodX: periodX,\n    periodY: periodY,\n    octave,\n    scale,\n  };\n}\n\n/**\n * Sample 1D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample1(config: ReturnType<typeof cubicNoiseConfig>, x: number) {\n  const xi = Math.floor(x);\n  const lerp = x - xi;\n\n  return (\n    interpolate(\n      randomize(config.seed, tile(xi - 1, config.periodX), 0),\n      randomize(config.seed, tile(xi, config.periodX), 0),\n      randomize(config.seed, tile(xi + 1, config.periodX), 0),\n      randomize(config.seed, tile(xi + 2, config.periodX), 0),\n      lerp,\n      1,\n      1,\n    ) *\n      0.666666 +\n    0.166666\n  );\n}\n\n/**\n * Sample 2D cubic noise.\n * @param {Object} config A valid noise configuration.\n * @param {Number} x The X position to sample at.\n * @param {Number} y The Y position to sample at.\n * @returns {Number} A noise value in the range [0, 1].\n */\nexport function cubicNoiseSample2(\n  { octave, periodX, periodY, seed, scale }: ReturnType<typeof cubicNoiseConfig>,\n  x: number,\n  y: number,\n) {\n  const xi = Math.floor(x / octave);\n  const lerpX = Math.floor((x * ACCURACY) / octave) - xi * ACCURACY;\n  const yi = Math.floor(y / octave);\n  const lerpY = Math.floor((y * ACCURACY) / octave) - yi * ACCURACY;\n  const x0 = tile(xi - 1, periodX);\n  const x1 = tile(xi, periodX);\n  const x2 = tile(xi + 1, periodX);\n  const x3 = tile(xi + 2, periodX);\n\n  const xSamples = new Array(4);\n\n  for (let i = 0; i < 4; ++i) {\n    const y = tile(yi - 1 + i, periodY);\n\n    xSamples[i] = interpolate(\n      randomize(seed, x0, y),\n      randomize(seed, x1, y),\n      randomize(seed, x2, y),\n      randomize(seed, x3, y),\n      lerpX,\n      ACCURACY,\n      1,\n    );\n  }\n\n  return Math.floor(\n    interpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], lerpY, ACCURACY, scale) / Math.pow(ACCURACY, 6),\n  );\n}\n", "const TOPICS_KEY = \"mud-logger-topics\";\n\nexport function enableLogger() {\n  const windowConsole = window.console;\n  let filtersActive = Boolean(localStorage.getItem(TOPICS_KEY));\n\n  const topicsString = localStorage.getItem(TOPICS_KEY);\n  let topics: string[] = topicsString ? JSON.parse(topicsString) : [];\n\n  function log(...logs: string[]) {\n    if (filtersActive) return;\n    windowConsole.log(...logs);\n  }\n\n  function logWithTopic(topic: string, ...logs: string[]) {\n    if (!filtersActive || topics.includes(topic)) {\n      windowConsole.log(`--- BETTER CONSOLE / TOPIC ${topic} ---`);\n      windowConsole.log(...logs);\n    }\n  }\n\n  function enableFilters() {\n    localStorage.setItem(TOPICS_KEY, JSON.stringify([]));\n    filtersActive = true;\n  }\n\n  function disableFilters() {\n    localStorage.removeItem(TOPICS_KEY);\n    filtersActive = false;\n  }\n\n  function addTopic(topic: string) {\n    topics.push(topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function removeTopic(topic: string) {\n    topics = topics.filter((t) => t !== topic);\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  function resetTopics() {\n    topics = [];\n    localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));\n  }\n\n  const logger = {\n    ...windowConsole,\n    log,\n    logWithTopic,\n    enableFilters,\n    disableFilters,\n    addTopic,\n    removeTopic,\n    resetTopics,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).logger = logger;\n  window.console = logger;\n  return logger;\n}\n", "/**\n * Compute the Euclidean distance between two points\n * https://en.wikipedia.org/wiki/Euclidean_distance\n * @param a\n * @param b\n * @returns Euclidian distance between a and b\n */\nexport function euclidean(a: number[], b: number[]): number {\n  if (a.length !== b.length) throw new Error(\"points must have same dimension\");\n  return Math.sqrt(a.reduce((acc, _, i) => acc + Math.pow(a[i] - b[i], 2), 0));\n}\n", "/**\n * For positive inputs: returns the greatest integer less than or equal to its numeric argument.\n * For negative inputs: returns the smallest integer greater than or equal to its numeric argument.\n *\n * @param x A numeric expression.\n * @returns Input rounded towards zero.\n */\nexport function roundTowardsZero(x: number) {\n  const sign = x < 0 ? -1 : 1;\n  return sign * Math.floor(Math.abs(x));\n}\n", "// TODO: migrate to viem's toHex()\nexport const arrayToHex = (array: Uint8Array | ArrayBuffer): `0x${string}` =>\n  `0x${[...new Uint8Array(array)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\")}`;\n", "export const bytesToString = (bytes: Uint8Array): string => [...bytes].map((x) => String.fromCharCode(x)).join(\"\");\n", "// TODO: migrate to viem's isHex()\n// Note that this assumes hex pairs, but viem does not. We'll need to be careful migrating.\n// Padding an odd-length hex sounds scary (based on how Solidity left/right aligns numbers vs bytes/strings).\nexport function isHex(hex: string): boolean {\n  return /^(0x)?([\\da-f]{2})*$/i.test(hex);\n}\n", "import { isHex } from \"./isHex\";\n\n// TODO: migrate to viem's toBytes(hex)\nexport const hexToArray = (hex: string): Uint8Array => {\n  if (!isHex(hex)) {\n    console.error(\"Invalid hex string\", hex);\n    throw new Error(\"Invalid hex string\");\n  }\n  const bytes = hex.match(/[\\da-f]{2}/gi);\n  if (!bytes) return new Uint8Array([]);\n  return new Uint8Array(bytes.map((byte) => parseInt(byte, 16)));\n};\n", "export const stringToBytes16 = (str: string): Uint8Array => {\n  if (str.length > 16) throw new Error(\"string too long\");\n  return new Uint8Array(16).map((v, i) => str.charCodeAt(i));\n};\n\nexport const stringToBytes32 = (str: string): Uint8Array => {\n  if (str.length > 32) throw new Error(\"string too long\");\n  return new Uint8Array(32).map((v, i) => str.charCodeAt(i));\n};\n", "import { toEthAddress } from \"./eth\";\nimport { hexToArray } from \"./v2\";\n\nexport function formatHex(hex: string): string {\n  if (hex.substring(0, 2) == \"0x\") hex = hex.substring(2);\n  const prefix = hex.length % 2 !== 0 ? \"0x0\" : \"0x\";\n  return prefix + hex;\n}\n\nexport function hexStringToUint8Array(hexString: string): Uint8Array {\n  return hexToArray(hexString);\n}\n\nexport function Uint8ArrayToHexString(data: Uint8Array): string {\n  if (data.length === 0) return \"0x00\";\n  return formatHex(data.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\"));\n}\n\nexport function concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\n  return Uint8Array.from(\n    arrays.reduce<number[]>((acc, curr) => {\n      return [...acc, ...curr];\n    }, []),\n  );\n}\n\nexport function splitUint8Arrays(data: Uint8Array, byteLengths: number[]): Uint8Array[] {\n  const arrays: Uint8Array[] = [];\n  let i = 0;\n  for (const length of byteLengths) {\n    const array = new Uint8Array(length);\n    arrays.push(array);\n    for (let j = 0; j < length; j++) {\n      array[j] = data[i];\n      i++;\n    }\n  }\n  return arrays;\n}\n\nexport function Int32ArrayToUint8Array(input: number[]): Uint8Array {\n  const buffer = new ArrayBuffer(input.length * 4);\n  const int32arr = new Int32Array(buffer);\n  for (let i = 0; i < input.length; i++) {\n    int32arr[i] = input[i];\n  }\n  return new Uint8Array(buffer);\n}\n\nexport function Uint8ArrayToInt32Array(input: Uint8Array): number[] {\n  return [...new Int32Array(input.buffer)];\n}\n\nexport function ethAddressToUint8Array(address: string): Uint8Array {\n  return hexStringToUint8Array(toEthAddress(address));\n}\n\n// https://stackoverflow.com/a/55330424\nexport function createToInt(size: number) {\n  if (size < 2) {\n    throw new Error(\"Minimum size is 2\");\n  } else if (size > 64) {\n    throw new Error(\"Maximum size is 64\");\n  }\n\n  // Determine value range\n  const maxValue = 2 ** (size - 1) - 1;\n  const minValue = -maxValue - 1;\n\n  return (value: number) => {\n    value = value << 0;\n    if (value > maxValue || value < minValue) {\n      console.log(\"value\", value, maxValue, minValue, value > maxValue, value < minValue);\n      throw new Error(`Int${size} overflow`);\n    }\n\n    if (value < 0) {\n      return 2 ** size + value;\n    } else {\n      return value;\n    }\n  };\n}\n\nexport const toInt32 = createToInt(32);\n"],
  "mappings": "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",
  "names": ["isNotEmpty", "array", "filterNullishValues", "value", "deferred", "resolve", "reject", "promise", "r", "rj", "t", "e", "awaitValue", "comp", "dispose", "reaction", "isObject", "c", "isFunction", "deepAccess", "target", "path", "next", "rest", "nextTarget", "cacheUntilReady", "callQueue", "proxiedTarget", "DeepProxy", "_t", "prop", "targetReady", "_", "thisArg", "args", "targetFunc", "queuedCalls", "numValues", "enm", "nums", "val", "mapObject", "source", "valueMap", "key", "random", "to", "from", "pickRandom", "filterNullish", "pipe", "filter", "x", "awaitPromise", "concatMap", "stretch", "spacingDelayMs", "timestamp", "scan", "acc", "curr", "delay", "timeDelta", "mergeMap", "i", "of", "observableToComputed", "obs", "computed", "computedToStream", "stream", "ReplaySubject", "observableToStream", "toJS", "streamToComputed", "stream$", "observable", "runInAction", "streamToDefinedComputed", "computedValue", "awaitStreamValue", "predicate", "first", "streamToWrappedValue", "v", "uuid", "rand", "_getRandomInt", "hex", "_hexAligner", "n", "num", "length", "str", "z", "sleep", "timeout", "returns", "range", "total", "step", "rejectAfter", "ms", "msg", "timeoutAfter", "timeoutMsg", "callWithRetry", "fn", "maxRetries", "retryInterval", "res", "makeIterable", "iterator", "concatIterators", "second", "mergeIterators", "iteratorA", "iteratorB", "nextA", "nextB", "transformIterator", "transform", "done", "arrayToIterator", "areaContains", "area", "coord", "coordsOf", "coords", "dx", "dy", "fromWorker", "worker", "input$", "event", "fromEvent", "map", "runWorker", "rightMask", "input", "keep", "pack", "numbers", "bitsPerNumber", "error", "packed", "unpack", "shiftedPacked", "packTuple", "unpackTuple", "LOWER_HALF_MASK", "MAX_SUPPORTED", "subtract", "result", "CoordMap", "coordToKey", "keyToCoord", "y", "props", "coordMapLike", "coordMap", "fragments", "VoxelCoordMap", "padToBitLength", "bits", "toEthAddress", "to256BitString", "extractEncodedArguments", "randomize", "seed", "tile", "coordinate", "period", "interpolate", "a", "b", "d", "s", "scale", "p", "cubicNoiseConfig", "octave", "periodX", "periodY", "cubicNoiseSample1", "config", "xi", "lerp", "cubicNoiseSample2", "lerpX", "yi", "lerpY", "x0", "x1", "x2", "x3", "xSamples", "TOPICS_KEY", "enableLogger", "windowConsole", "filtersActive", "topicsString", "topics", "log", "logs", "logWithTopic", "topic", "enableFilters", "disableFilters", "addTopic", "removeTopic", "resetTopics", "logger", "euclidean", "roundTowardsZero", "arrayToHex", "bytesToString", "bytes", "isHex", "hexToArray", "byte", "stringToBytes16", "stringToBytes32", "formatHex", "hexStringToUint8Array", "hexString", "Uint8ArrayToHexString", "data", "concatUint8Arrays", "arrays", "splitUint8Arrays", "byteLengths", "j", "Int32ArrayToUint8Array", "buffer", "int32arr", "Uint8ArrayToInt32Array", "ethAddressToUint8Array", "address", "createToInt", "size", "maxValue", "minValue", "toInt32"]
}
